import { chmod, mkdir, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join } from "node:path";

function generateStatuslineMonitorScript(): string {
  // Keep this script dependency-free (Node built-ins only). It runs from the wrapper via `node`.
  return `#!/usr/bin/env node
/* Auto-generated by droid-patch --statusline */

const fs = require('fs');
const os = require('os');
const path = require('path');
const { spawn, spawnSync } = require('child_process');

// This monitor does NOT draw directly to the terminal. It emits newline-delimited
// statusline frames to stdout. A wrapper (PTY proxy) is responsible for rendering
// the latest frame on a reserved bottom row to avoid flicker.

const FACTORY_HOME = path.join(os.homedir(), '.factory');

const SESSIONS_ROOT = path.join(FACTORY_HOME, 'sessions');
const LOG_PATH = path.join(FACTORY_HOME, 'logs', 'droid-log-single.log');
const CONFIG_PATH = path.join(FACTORY_HOME, 'config.json');
const GLOBAL_SETTINGS_PATH = path.join(FACTORY_HOME, 'settings.json');

const IS_APPLE_TERMINAL = process.env.TERM_PROGRAM === 'Apple_Terminal';
const MIN_RENDER_INTERVAL_MS = IS_APPLE_TERMINAL ? 1000 : 500;

const START_MS = Date.now();
const ARGS = process.argv.slice(2);
const PGID = Number(process.env.DROID_STATUSLINE_PGID || '');
const SESSION_ID_RE = /"sessionId":"([0-9a-f-]{36})"/i;

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function isPositiveInt(n) {
  return Number.isFinite(n) && n > 0;
}

function extractSessionIdFromLine(line) {
  if (!line) return null;
  const m = String(line).match(SESSION_ID_RE);
  return m ? m[1] : null;
}

function parseLineTimestampMs(line) {
  const s = String(line || '');
  if (!s || s[0] !== '[') return null;
  const end = s.indexOf(']');
  if (end <= 1) return null;
  const raw = s.slice(1, end);
  const ms = Date.parse(raw);
  return Number.isFinite(ms) ? ms : null;
}

function safeStatMtimeMs(p) {
  try {
    const stat = fs.statSync(p);
    const ms = Number(stat?.mtimeMs ?? 0);
    return Number.isFinite(ms) ? ms : 0;
  } catch {
    return 0;
  }
}

function nextCompactionState(line, current) {
  if (!line) return current;
  if (line.includes('[Compaction] Start')) return true;
  const endMarkers = ['End', 'Done', 'Finish', 'Finished', 'Complete', 'Completed'];
  if (endMarkers.some(m => line.includes('[Compaction] ' + m))) return false;
  return current;
}

function firstNonNull(promises) {
  const list = Array.isArray(promises) ? promises : [];
  if (list.length === 0) return Promise.resolve(null);
  return new Promise((resolve) => {
    let pending = list.length;
    let done = false;
    for (const p of list) {
      Promise.resolve(p)
        .then((value) => {
          if (done) return;
          if (value) {
            done = true;
            resolve(value);
            return;
          }
          pending -= 1;
          if (pending <= 0) resolve(null);
        })
        .catch(() => {
          if (done) return;
          pending -= 1;
          if (pending <= 0) resolve(null);
        });
    }
  });
}

function listPidsInProcessGroup(pgid) {
  if (!isPositiveInt(pgid)) return [];
  try {
    const res = spawnSync('ps', ['-ax', '-o', 'pid=,pgid='], {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (!res || res.status !== 0) return [];
    const out = String(res.stdout || '');
    const pids = [];
    for (const line of out.split('\\n')) {
      const parts = line.trim().split(/\\s+/);
      if (parts.length < 2) continue;
      const pid = Number(parts[0]);
      const g = Number(parts[1]);
      if (Number.isFinite(pid) && g === pgid) pids.push(pid);
    }
    return pids;
  } catch {
    return [];
  }
}

function resolveOpenSessionFromPids(pids) {
  if (!Array.isArray(pids) || pids.length === 0) return null;
  // lsof prints file names as lines prefixed with "n" when using -Fn
  try {
    const res = spawnSync('lsof', ['-p', pids.join(','), '-Fn'], {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 1200,
    });
    if (!res || res.status !== 0) return null;
    const out = String(res.stdout || '');
    for (const line of out.split('\\n')) {
      if (!line || line[0] !== 'n') continue;
      const name = line.slice(1);
      if (!name.startsWith(SESSIONS_ROOT + path.sep)) continue;
      const m = name.match(/([0-9a-f-]{36})\\.(jsonl|settings\\.json)$/i);
      if (!m) continue;
      const id = m[1];
      const workspaceDir = path.dirname(name);
      if (path.dirname(workspaceDir) !== SESSIONS_ROOT) continue;
      return { workspaceDir, id };
    }
  } catch {
    return null;
  }
  return null;
}

async function resolveSessionFromProcessGroup(shouldAbort, maxTries = 20) {
  if (!isPositiveInt(PGID)) return null;
  // Wait a little for droid to create/open the session files.
  for (let i = 0; i < maxTries; i++) {
    if (shouldAbort && shouldAbort()) return null;
    const pids = listPidsInProcessGroup(PGID);
    const found = resolveOpenSessionFromPids(pids);
    if (found) return found;
    await sleep(100);
  }
  return null;
}

function safeReadFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch {
    return null;
  }
}

function safeJsonParse(text) {
  if (!text) return null;
  try {
    // Factory settings/config files can contain comments. Strip them safely without
    // breaking URLs like "http://..." which contain "//" inside strings.
    const stripComments = (input) => {
      let out = '';
      let inString = false;
      let escape = false;
      for (let i = 0; i < input.length; i++) {
        const ch = input[i];
        const next = input[i + 1];

        if (inString) {
          out += ch;
          if (escape) {
            escape = false;
            continue;
          }
          if (ch === '\\\\') {
            escape = true;
            continue;
          }
          if (ch === '"') {
            inString = false;
          }
          continue;
        }

        if (ch === '"') {
          inString = true;
          out += ch;
          continue;
        }

        // Line comment
        if (ch === '/' && next === '/') {
          while (i < input.length && input[i] !== '\\n') i++;
          out += '\\n';
          continue;
        }

        // Block comment
        if (ch === '/' && next === '*') {
          i += 2;
          while (i < input.length && !(input[i] === '*' && input[i + 1] === '/')) i++;
          i += 1;
          continue;
        }

        out += ch;
      }
      return out;
    };

    return JSON.parse(stripComments(text));
  } catch {
    return null;
  }
}

function readJsonFile(filePath) {
  return safeJsonParse(safeReadFile(filePath));
}

function isUuid(text) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(text);
}

function parseResume(args) {
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '-r' || a === '--resume') {
      const next = args[i + 1];
      if (next && isUuid(next)) return { resumeFlag: true, resumeId: next };
      return { resumeFlag: true, resumeId: null };
    }
    if (a.startsWith('--resume=')) {
      const value = a.slice('--resume='.length);
      return { resumeFlag: true, resumeId: isUuid(value) ? value : null };
    }
  }
  return { resumeFlag: false, resumeId: null };
}

function sanitizeWorkspaceDirName(cwd) {
  return String(cwd)
    .replace(/[:]/g, '')
    .replace(/[\\\\/]/g, '-')
    .replace(/\\s+/g, '-');
}

function listSessionCandidates(workspaceDir) {
  let files = [];
  try {
    files = fs.readdirSync(workspaceDir);
  } catch {
    return [];
  }
  const candidates = [];
  for (const file of files) {
    const m = file.match(/^([0-9a-f-]{36})\\.(jsonl|settings\\.json)$/i);
    if (!m) continue;
    const id = m[1];
    const fullPath = path.join(workspaceDir, file);
    try {
      const stat = fs.statSync(fullPath);
      candidates.push({ id, fullPath, mtimeMs: stat.mtimeMs });
    } catch {
      // ignore
    }
  }
  return candidates;
}

function findWorkspaceDirForSessionId(workspaceDirs, sessionId) {
  for (const dir of workspaceDirs) {
    try {
      const settingsPath = path.join(dir, sessionId + '.settings.json');
      if (fs.existsSync(settingsPath)) return dir;
    } catch {
      // ignore
    }
  }
  return null;
}

function pickLatestSessionAcross(workspaceDirs) {
  let best = null;
  for (const dir of workspaceDirs) {
    const candidates = listSessionCandidates(dir);
    for (const c of candidates) {
      if (!best || c.mtimeMs > best.mtimeMs) {
        best = { workspaceDir: dir, id: c.id, mtimeMs: c.mtimeMs };
      }
    }
  }
  return best ? { workspaceDir: best.workspaceDir, id: best.id } : null;
}

async function waitForNewSessionAcross(workspaceDirs, knownIdsByWorkspace, startMs, shouldAbort) {
  for (let i = 0; i < 80; i++) {
    if (shouldAbort && shouldAbort()) return null;
    let best = null;
    for (const dir of workspaceDirs) {
      const known = knownIdsByWorkspace.get(dir) || new Set();
      const candidates = listSessionCandidates(dir);
      for (const c of candidates) {
        if (!(c.mtimeMs >= startMs - 50 || !known.has(c.id))) continue;
        if (!best || c.mtimeMs > best.mtimeMs) {
          best = { workspaceDir: dir, id: c.id, mtimeMs: c.mtimeMs };
        }
      }
    }
    if (best?.id) return { workspaceDir: best.workspaceDir, id: best.id };
    await sleep(100);
  }
  return null;
}

function safeRealpath(p) {
  try {
    return fs.realpathSync(p);
  } catch {
    return null;
  }
}

function resolveWorkspaceDirs(cwd) {
  const logical = cwd;
  const real = safeRealpath(cwd);
  const dirs = [];
  for (const value of [logical, real]) {
    if (!value || typeof value !== 'string') continue;
    dirs.push(path.join(SESSIONS_ROOT, sanitizeWorkspaceDirName(value)));
  }
  return Array.from(new Set(dirs));
}

function resolveSessionSettings(workspaceDir, sessionId) {
  const settingsPath = path.join(workspaceDir, sessionId + '.settings.json');
  const settings = readJsonFile(settingsPath) || {};
  return { settingsPath, settings };
}

function resolveGlobalSettingsModel() {
  const global = readJsonFile(GLOBAL_SETTINGS_PATH);
  return global && typeof global.model === 'string' ? global.model : null;
}

function resolveCustomModelIndex(modelId) {
  if (typeof modelId !== 'string') return null;
  if (!modelId.startsWith('custom:')) return null;
  const m = modelId.match(/-(\\d+)$/);
  if (!m) return null;
  const idx = Number(m[1]);
  return Number.isFinite(idx) ? idx : null;
}

function resolveUnderlyingModelId(modelId, factoryConfig) {
  const idx = resolveCustomModelIndex(modelId);
  if (idx == null) return modelId;
  const entry = factoryConfig?.custom_models?.[idx];
  if (entry && typeof entry.model === 'string') return entry.model;
  return modelId;
}

function resolveProvider(modelId, factoryConfig) {
  const idx = resolveCustomModelIndex(modelId);
  if (idx != null) {
    const entry = factoryConfig?.custom_models?.[idx];
    if (entry && typeof entry.provider === 'string') return entry.provider;
  }
  if (typeof modelId === 'string' && modelId.startsWith('claude-')) return 'anthropic';
  return '';
}

function formatInt(n) {
  if (!Number.isFinite(n)) return '0';
  return Math.round(n).toString();
}

function formatTokens(n) {
  if (!Number.isFinite(n)) return '0';
  const sign = n < 0 ? '-' : '';
  const abs = Math.abs(n);
  if (abs >= 1_000_000) {
    const v = abs / 1_000_000;
    const s = v >= 10 ? v.toFixed(0) : v.toFixed(1);
    return sign + s.replace(/\\.0$/, '') + 'M';
  }
  if (abs >= 10_000) {
    const v = abs / 1_000;
    const s = v >= 100 ? v.toFixed(0) : v.toFixed(1);
    return sign + s.replace(/\\.0$/, '') + 'k';
  }
  return sign + Math.round(abs).toString();
}

function emitFrame(line) {
  try {
    process.stdout.write(String(line || '') + '\\n');
  } catch {
    // ignore
  }
}

function seg(bg, fg, text) {
  if (!text) return '';
  return '\\x1b[48;5;' + bg + 'm' + '\\x1b[38;5;' + fg + 'm' + ' ' + text + ' ' + '\\x1b[0m';
}

function resolveGitBranch(cwd) {
  try {
    const res = spawnSync('git', ['rev-parse', '--abbrev-ref', 'HEAD'], {
      cwd,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (res && res.status === 0) {
      const branch = String(res.stdout || '').trim();
      if (branch && branch !== 'HEAD') return branch;
    }
  } catch {}
  try {
    const headPath = path.join(cwd, '.git', 'HEAD');
    const head = safeReadFile(headPath);
    if (head && head.startsWith('ref: ')) {
      const ref = head.slice('ref: '.length).trim();
      const m = ref.match(/refs\\/heads\\/(.+)$/);
      if (m) return m[1];
    }
  } catch {}
  return '';
}

function resolveGitDiffSummary(cwd) {
  try {
    const res = spawnSync('git', ['diff', '--shortstat'], {
      cwd,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (!res || res.status !== 0) return '';
    const text = String(res.stdout || '').trim();
    if (!text) return '';
    const ins = (text.match(/(\\d+)\\sinsertions?\\(\\+\\)/) || [])[1];
    const del = (text.match(/(\\d+)\\sdeletions?\\(-\\)/) || [])[1];
    const i = ins ? Number(ins) : 0;
    const d = del ? Number(del) : 0;
    if (!Number.isFinite(i) && !Number.isFinite(d)) return '';
    if (i === 0 && d === 0) return '';
    return '(+' + formatInt(i) + ',-' + formatInt(d) + ')';
  } catch {
    return '';
  }
}

function buildLine(params) {
  const {
    provider,
    model,
    cwdBase,
    gitBranch,
    gitDiff,
    usedTokens,
    cacheRead,
    deltaInput,
    lastOutputTokens,
    sessionUsage,
    compacting,
    ctxAvailable,
    ctxApprox,
    ctxOverflow,
  } = params;

  const ctxValue = !ctxAvailable
    ? '--'
    : (ctxApprox ? '~' : '') + formatTokens(usedTokens) + (ctxOverflow ? '+' : '');
  let ctxPart = 'Ctx: ' + ctxValue;

  const cachePart =
    ctxAvailable && !ctxApprox && !ctxOverflow && (cacheRead > 0 || deltaInput > 0)
      ? ' c' + formatTokens(cacheRead) + '+n' + formatTokens(deltaInput)
      : '';

  const compactPart = compacting ? ' COMPACT' : '';

  const usagePart = (() => {
    const u = sessionUsage || {};
    const input = Number(u.inputTokens ?? 0);
    const output = Number(u.outputTokens ?? 0);
    const cacheCreation = Number(u.cacheCreationTokens ?? 0);
    const cacheReadTotal = Number(u.cacheReadTokens ?? 0);
    const thinking = Number(u.thinkingTokens ?? 0);
    if (!(input || output || cacheCreation || cacheReadTotal || thinking)) return '';
    const parts = [];
    if (input) parts.push('In:' + formatTokens(input));
    if (output) parts.push('Out:' + formatTokens(output));
    if (cacheCreation) parts.push('Cre:' + formatTokens(cacheCreation));
    if (cacheReadTotal) parts.push('Read:' + formatTokens(cacheReadTotal));
    if (thinking) parts.push('Think:' + formatTokens(thinking));
    if (lastOutputTokens > 0) parts.push('LastOut:' + formatTokens(lastOutputTokens));
    return parts.join(' ');
  })();

  const modelPart = model ? 'Model: ' + model : '';
  const providerPart = provider ? 'Prov: ' + provider : '';
  const cwdPart = cwdBase ? 'cwd: ' + cwdBase : '';
  const branchPart = gitBranch ? '\\uE0A0 ' + gitBranch : '';
  const diffPart = gitDiff || '';

  // Background segments (powerline-like blocks)
  const sModel = seg(88, 15, modelPart); // dark red
  const sProvider = seg(160, 15, providerPart); // red
  const sCtx = seg(220, 0, ctxPart + (cachePart ? ' (' + cachePart.trim() + ')' : '')); // yellow
  const sUsage = seg(173, 0, usagePart); // orange-ish
  const sBranch = seg(24, 15, branchPart); // blue
  const sDiff = seg(34, 0, diffPart); // green
  const sCwd = seg(238, 15, cwdPart); // gray
  const sExtra = seg(99, 15, compactPart.trim()); // purple-ish

  return [sModel, sProvider, sCtx, sUsage, sBranch, sDiff, sCwd, sExtra].filter(Boolean).join('');
}

async function main() {
  let factoryConfig = readJsonFile(CONFIG_PATH) || {};

  const cwd = process.cwd();
  const cwdBase = path.basename(cwd) || cwd;
  const workspaceDirs = resolveWorkspaceDirs(cwd);
  const knownIdsByWorkspace = new Map();
  for (const dir of workspaceDirs) {
    const set = new Set();
    for (const c of listSessionCandidates(dir)) set.add(c.id);
    knownIdsByWorkspace.set(dir, set);
  }

  const { resumeFlag, resumeId } = parseResume(ARGS);

  let sessionId = null;
  let workspaceDir = null;
  if (resumeId) {
    sessionId = resumeId;
    workspaceDir = findWorkspaceDirForSessionId(workspaceDirs, sessionId) || workspaceDirs[0] || null;
  } else {
    let abortResolve = false;
    const shouldAbort = () => abortResolve;

    const byProcPromise = resolveSessionFromProcessGroup(shouldAbort, 20);

    let picked = null;
    if (resumeFlag) {
      // For --resume without an explicit id, don't block startup too long on ps/lsof.
      // Prefer process-group resolution when it is fast; otherwise fall back to latest.
      picked = await Promise.race([
        byProcPromise,
        sleep(400).then(() => null),
      ]);
      if (!picked) picked = pickLatestSessionAcross(workspaceDirs);
    } else {
      const freshPromise = waitForNewSessionAcross(workspaceDirs, knownIdsByWorkspace, START_MS, shouldAbort);
      picked = await firstNonNull([byProcPromise, freshPromise]);
      if (!picked) picked = pickLatestSessionAcross(workspaceDirs);
    }

    abortResolve = true;

    sessionId = picked?.id || null;
    workspaceDir = picked?.workspaceDir || workspaceDirs[0] || null;
  }

  if (!sessionId || !workspaceDir) return;
  let sessionIdLower = String(sessionId).toLowerCase();

  let settingsPath = '';
  let sessionSettings = {};
  ({ settingsPath, settings: sessionSettings } = resolveSessionSettings(workspaceDir, sessionId));

  let configMtimeMs = safeStatMtimeMs(CONFIG_PATH);
  let globalSettingsMtimeMs = safeStatMtimeMs(GLOBAL_SETTINGS_PATH);
  let globalSettingsModel = resolveGlobalSettingsModel();

  let modelIdFromLog = null;

  function resolveActiveModelId() {
    const fromSession =
      sessionSettings && typeof sessionSettings.model === 'string' ? sessionSettings.model : null;
    if (fromSession && String(fromSession).startsWith('custom:')) return fromSession;
    const fromLog = typeof modelIdFromLog === 'string' ? modelIdFromLog : null;
    if (fromLog) return fromLog;
    return fromSession || globalSettingsModel || null;
  }

  let modelId = resolveActiveModelId();

  let provider =
    sessionSettings && typeof sessionSettings.providerLock === 'string'
      ? sessionSettings.providerLock
      : resolveProvider(modelId, factoryConfig);
  let underlyingModel = resolveUnderlyingModelId(modelId, factoryConfig) || modelId || 'unknown';

  function refreshModel() {
    const nextModelId = resolveActiveModelId();

    // Use providerLock if set, otherwise resolve from model/config (same logic as initialization)
    const nextProvider =
      sessionSettings && typeof sessionSettings.providerLock === 'string'
        ? sessionSettings.providerLock
        : resolveProvider(nextModelId, factoryConfig);
    const nextUnderlying = resolveUnderlyingModelId(nextModelId, factoryConfig) || nextModelId || 'unknown';

    let changed = false;
    if (nextModelId !== modelId) {
      modelId = nextModelId;
      changed = true;
    }
    if (nextProvider !== provider) {
      provider = nextProvider;
      changed = true;
    }
    if (nextUnderlying !== underlyingModel) {
      underlyingModel = nextUnderlying;
      changed = true;
    }

    if (changed) renderNow();
  }

  let last = { cacheReadInputTokens: 0, contextCount: 0, outputTokens: 0 };
  let sessionUsage =
    sessionSettings && typeof sessionSettings.tokenUsage === 'object' && sessionSettings.tokenUsage
      ? sessionSettings.tokenUsage
      : {};
  let compacting = false;
  let lastRenderAt = 0;
  let lastRenderedLine = '';
  let gitBranch = '';
  let gitDiff = '';
  let lastContextMs = 0;
  let ctxAvailable = false;
  let ctxApprox = false;
  let ctxOverflow = false;
  let ctxOverrideUsedTokens = null;

  let baselineCacheReadInputTokens = 0;
  let knownContextMaxTokens = 0;
  let pendingCompactionSuffixTokens = null;
  let pendingCompactionSummaryOutputTokens = null;
  let pendingCompactionSummaryTsMs = null;

  function renderNow() {
    const override = Number.isFinite(ctxOverrideUsedTokens) && ctxOverrideUsedTokens > 0 ? ctxOverrideUsedTokens : null;
    const usedTokens = override != null ? override : (last.cacheReadInputTokens || 0) + (last.contextCount || 0);
    const cacheRead = override != null ? 0 : last.cacheReadInputTokens || 0;
    const deltaInput = override != null ? 0 : last.contextCount || 0;
    const line = buildLine({
      provider,
      model: underlyingModel,
      cwdBase,
      gitBranch,
      gitDiff,
      usedTokens,
      cacheRead,
      deltaInput,
      lastOutputTokens: last.outputTokens || 0,
      sessionUsage,
      compacting,
      ctxAvailable: override != null ? true : ctxAvailable,
      ctxApprox,
      ctxOverflow,
    });
    if (line !== lastRenderedLine) {
      lastRenderedLine = line;
      emitFrame(line);
    }
  }

  // Initial render.
  renderNow();

  // Resolve git info asynchronously so startup isn't blocked on large repos.
  setTimeout(() => {
    try {
      gitBranch = resolveGitBranch(cwd);
      gitDiff = resolveGitDiffSummary(cwd);
      renderNow();
    } catch {}
  }, 0).unref();

  // Seed known context max tokens from recent log failures (some providers omit explicit counts).
  setTimeout(() => {
    try {
      seedKnownContextMaxTokensFromLog(8 * 1024 * 1024);
    } catch {}
  }, 0).unref();

  let reseedInProgress = false;
  let reseedQueued = false;

  function extractModelIdFromContext(ctx) {
    const tagged = ctx?.tags?.modelId;
    if (typeof tagged === 'string') return tagged;
    const direct = ctx?.modelId;
    return typeof direct === 'string' ? direct : null;
  }

  function updateLastFromContext(ctx, updateOutputTokens, tsMs) {
    const ts = Number.isFinite(tsMs) ? tsMs : null;
    if (ts != null && lastContextMs && ts < lastContextMs) return false;
    const cacheRead = Number(ctx?.cacheReadInputTokens);
    const contextCount = Number(ctx?.contextCount);
    const out = Number(ctx?.outputTokens);
    const hasTokens =
      (Number.isFinite(cacheRead) && cacheRead > 0) ||
      (Number.isFinite(contextCount) && contextCount > 0);
    if (hasTokens) {
      // Treat 0/0 as "not reported" (some providers log zeros even when prompt exists).
      // If at least one field is >0, accept both fields (including zero) as reliable.
      if (Number.isFinite(cacheRead)) last.cacheReadInputTokens = cacheRead;
      if (Number.isFinite(contextCount)) last.contextCount = contextCount;
      ctxAvailable = true;
      ctxOverrideUsedTokens = null;
      ctxApprox = false;
      ctxOverflow = false;
      if (Number.isFinite(cacheRead) && cacheRead > 0) {
        baselineCacheReadInputTokens = baselineCacheReadInputTokens
          ? Math.min(baselineCacheReadInputTokens, cacheRead)
          : cacheRead;
      }
    }
    if (updateOutputTokens && Number.isFinite(out)) last.outputTokens = out;
    if (hasTokens && ts != null) lastContextMs = ts;

    const nextModelIdFromLog = extractModelIdFromContext(ctx);
    if (nextModelIdFromLog && nextModelIdFromLog !== modelIdFromLog) {
      modelIdFromLog = nextModelIdFromLog;
      refreshModel();
    }

    return true;
  }

  function setCtxOverride(usedTokens, options) {
    const opts = options || {};
    const v = Number(usedTokens);
    if (!Number.isFinite(v) || v <= 0) return false;
    const prevUsed = ctxOverrideUsedTokens;
    const prevApprox = ctxApprox;
    const prevOverflow = ctxOverflow;
    ctxOverrideUsedTokens = v;
    ctxAvailable = true;
    ctxApprox = !!opts.approx;
    ctxOverflow = !!opts.overflow;
    const ts = Number.isFinite(opts.tsMs) ? opts.tsMs : null;
    if (ts != null && (!lastContextMs || ts > lastContextMs)) lastContextMs = ts;
    if (prevUsed !== ctxOverrideUsedTokens || prevApprox !== ctxApprox || prevOverflow !== ctxOverflow) {
      renderNow();
    }
    return true;
  }

  function parseContextLimitFromMessage(message) {
    const s = String(message || '');
    let promptTokens = null;
    let maxTokens = null;

    const pair = s.match(/(\\d+)\\s*tokens\\s*>\\s*(\\d+)\\s*maximum/i);
    if (pair) {
      const prompt = Number(pair[1]);
      const max = Number(pair[2]);
      if (Number.isFinite(prompt)) promptTokens = prompt;
      if (Number.isFinite(max)) maxTokens = max;
      return { promptTokens, maxTokens };
    }

    const promptMatch = s.match(/prompt\\s+is\\s+too\\s+long:\\s*(\\d+)\\s*tokens/i);
    if (promptMatch) {
      const prompt = Number(promptMatch[1]);
      if (Number.isFinite(prompt)) promptTokens = prompt;
    }

    const maxMatch = s.match(/>\\s*(\\d+)\\s*maximum/i);
    if (maxMatch) {
      const max = Number(maxMatch[1]);
      if (Number.isFinite(max)) maxTokens = max;
    }

    return { promptTokens, maxTokens };
  }

  function seedKnownContextMaxTokensFromLog(maxScanBytes = 4 * 1024 * 1024) {
    try {
      const stat = fs.statSync(LOG_PATH);
      const size = Number(stat?.size ?? 0);
      if (!(size > 0)) return;

      const scan = Math.max(256 * 1024, maxScanBytes);
      const readSize = Math.min(size, scan);
      const start = Math.max(0, size - readSize);

      const buf = Buffer.alloc(readSize);
      const fd = fs.openSync(LOG_PATH, 'r');
      try {
        fs.readSync(fd, buf, 0, readSize, start);
      } finally {
        try {
          fs.closeSync(fd);
        } catch {}
      }

      const text = buf.toString('utf8');
      const re = /(\\d+)\\s*tokens\\s*>\\s*(\\d+)\\s*maximum/gi;
      let m;
      while ((m = re.exec(text))) {
        const max = Number(m[2]);
        if (Number.isFinite(max) && max > 0) knownContextMaxTokens = max;
      }
    } catch {}
  }

  function maybeUpdateCtxFromContextLimitFailure(line, ctx, tsMs) {
    if (!line || !ctx) return false;
    if (!String(line).includes('[Chat route failure]')) return false;
    const reason = ctx?.reason;
    if (reason !== 'llmContextExceeded') return false;

    const msg = ctx?.error?.message;
    if (typeof msg !== 'string' || !msg) return false;
    const parsed = parseContextLimitFromMessage(msg);
    const max = Number(parsed?.maxTokens);
    if (Number.isFinite(max) && max > 0) knownContextMaxTokens = max;

    const prompt = Number(parsed?.promptTokens);
    if (Number.isFinite(prompt) && prompt > 0) {
      return setCtxOverride(prompt, { tsMs, approx: false, overflow: false });
    }

    if (Number.isFinite(max) && max > 0) {
      return setCtxOverride(max, { tsMs, approx: false, overflow: true });
    }

    if (knownContextMaxTokens > 0) {
      return setCtxOverride(knownContextMaxTokens, { tsMs, approx: false, overflow: true });
    }

    return false;
  }

  function maybeCaptureCompactionSuffix(line, ctx) {
    if (!line || !ctx) return;
    if (!String(line).includes('[Compaction] Suffix selection')) return;
    const suffix = Number(ctx?.suffixTokens);
    if (Number.isFinite(suffix) && suffix >= 0) pendingCompactionSuffixTokens = suffix;
  }

  function maybeApplyPostCompactionEstimate(line, ctx, tsMs) {
    if (!line || !ctx) return false;
	    if (!String(line).includes('[Compaction] End')) return false;
	    if (ctx?.eventType !== 'compaction' || ctx?.state !== 'end') return false;
	    const reason = ctx?.reason || ctx?.tags?.compactionReason || null;
	    if (!(reason === 'context_limit' || reason === 'manual')) return false;

    const summaryOut = Number(ctx?.summaryOutputTokens);
    if (!Number.isFinite(summaryOut) || summaryOut < 0) return false;

    const prefix = baselineCacheReadInputTokens > 0 ? baselineCacheReadInputTokens : 0;
    const suffix = Number.isFinite(pendingCompactionSuffixTokens) ? pendingCompactionSuffixTokens : 0;
    pendingCompactionSuffixTokens = null;

    const est = prefix + suffix + summaryOut;
    if (est <= 0) return false;
    return setCtxOverride(est, { tsMs, approx: true, overflow: false });
  }

  function maybeApplyCompactSessionEstimate(sessionIdToEstimate, options, attempt = 0) {
    const opts = options && typeof options === 'object' ? options : {};
    const id = String(sessionIdToEstimate || '');
    if (!isUuid(id)) return;
    if (!workspaceDir) return;

    // forceApply allows overriding even if ctx is already set (useful for manual /compress)
    const forceApply = !!opts?.forceApply;
    if (!forceApply) {
      if (ctxAvailable) return;
      if (Number.isFinite(ctxOverrideUsedTokens) && ctxOverrideUsedTokens > 0) return;
    }

    const suffixVal = opts?.suffixTokens;
    const suffixTokens =
      typeof suffixVal === 'number' && Number.isFinite(suffixVal) && suffixVal >= 0 ? suffixVal : 0;
    const tsVal = opts?.tsMs;
    const ts = typeof tsVal === 'number' && Number.isFinite(tsVal) ? tsVal : null;

    const jsonlPath = path.join(workspaceDir, id + '.jsonl');
    let head = null;
    try {
      const fd = fs.openSync(jsonlPath, 'r');
      try {
        const maxBytes = 2 * 1024 * 1024;
        const buf = Buffer.alloc(maxBytes);
        const bytes = fs.readSync(fd, buf, 0, maxBytes, 0);
        head = buf.slice(0, Math.max(0, bytes)).toString('utf8');
      } finally {
        try {
          fs.closeSync(fd);
        } catch {}
      }
    } catch {
      head = null;
    }

    if (!head) {
      if (attempt < 40) {
        setTimeout(() => {
          maybeApplyCompactSessionEstimate(id, opts, attempt + 1);
        }, 150).unref();
      }
      return;
    }

    let summaryText = null;
    for (const raw of head.split('\\n')) {
      if (!raw) continue;
      let obj;
      try {
        obj = JSON.parse(raw);
      } catch {
        continue;
      }
      if (obj && obj.type === 'compaction_state' && typeof obj.summaryText === 'string') {
        summaryText = obj.summaryText;
        break;
      }
    }
    if (!summaryText) {
      if (attempt < 40) {
        setTimeout(() => {
          maybeApplyCompactSessionEstimate(id, opts, attempt + 1);
        }, 150).unref();
      }
      return;
    }

    // Rough token estimate (no tokenizer deps): English-like text averages ~4 chars/token.
    // Non-ASCII tends to be denser; use a smaller divisor.
    let ascii = 0;
    let other = 0;
    for (let i = 0; i < summaryText.length; i++) {
      const code = summaryText.charCodeAt(i);
      if (code <= 0x7f) ascii += 1;
      else other += 1;
    }
    const summaryTokens = Math.max(1, Math.ceil(ascii / 4 + other / 1.5));
    const prefix = baselineCacheReadInputTokens > 0 ? baselineCacheReadInputTokens : 0;
    const est = prefix + suffixTokens + summaryTokens;
    if (est > 0) setCtxOverride(est, { tsMs: ts, approx: true, overflow: false });
  }

  function seedLastContextFromLog(options) {
    const opts = options || {};
    const maxScanBytes = Number.isFinite(opts.maxScanBytes) ? opts.maxScanBytes : 64 * 1024 * 1024;
    const preferStreaming = !!opts.preferStreaming;
    const minTimestampMs = Number.isFinite(lastContextMs) && lastContextMs > 0 ? lastContextMs : 0;
    const earlyStopAfterBestBytes = Math.min(2 * 1024 * 1024, Math.max(256 * 1024, maxScanBytes));

    if (reseedInProgress) {
      reseedQueued = true;
      return;
    }
    reseedInProgress = true;

    setTimeout(() => {
      try {
        // Backward scan to find the most recent context entry for this session.
        // Prefer streaming context if requested; otherwise accept any context line
        // that includes cacheReadInputTokens/contextCount fields.
        const CHUNK_BYTES = 1024 * 1024; // 1 MiB

        const fd = fs.openSync(LOG_PATH, 'r');
        try {
          const stat = fs.fstatSync(fd);
          const size = Number(stat?.size ?? 0);
          let pos = size;
          let scanned = 0;
          let remainder = '';
          let bestCtx = null;
          let bestIsStreaming = false;
          let bestTs = null;
          let bestHasTs = false;
          let bytesSinceBest = 0;

          while (pos > 0 && scanned < maxScanBytes && (!bestHasTs || bytesSinceBest < earlyStopAfterBestBytes)) {
            const readSize = Math.min(CHUNK_BYTES, pos);
            const start = pos - readSize;
            const buf = Buffer.alloc(readSize);
            fs.readSync(fd, buf, 0, readSize, start);
            pos = start;
            scanned += readSize;
            bytesSinceBest += readSize;

            let text = buf.toString('utf8') + remainder;
            let lines = String(text).split('\\n');
            remainder = lines.shift() || '';
            if (pos === 0 && remainder) {
              lines.unshift(remainder);
              remainder = '';
            }

            for (let i = lines.length - 1; i >= 0; i--) {
              const line = String(lines[i] || '').trimEnd();
              if (!line) continue;
              if (!line.includes('Context:')) continue;
              const sid = extractSessionIdFromLine(line);
              if (!sid || String(sid).toLowerCase() !== sessionIdLower) continue;

              const isStreaming = line.includes('[Agent] Streaming result');
              if (preferStreaming && !isStreaming) continue;

              const ctxIndex = line.indexOf('Context: ');
              if (ctxIndex === -1) continue;
              const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
              let ctx;
              try {
                ctx = JSON.parse(jsonStr);
              } catch {
                continue;
              }

              const cacheRead = Number(ctx?.cacheReadInputTokens);
              const contextCount = Number(ctx?.contextCount);
              const hasUsage = Number.isFinite(cacheRead) || Number.isFinite(contextCount);
              if (!hasUsage) continue;

              const ts = parseLineTimestampMs(line);
              if (ts != null && minTimestampMs && ts < minTimestampMs) {
                continue;
              }

              if (ts != null) {
                if (!bestHasTs || ts > bestTs) {
                  bestCtx = ctx;
                  bestIsStreaming = isStreaming;
                  bestTs = ts;
                  bestHasTs = true;
                  bytesSinceBest = 0;
                }
              } else if (!bestHasTs && !bestCtx) {
                // No timestamps available yet: the first match when scanning backward
                // is the most recent in file order.
                bestCtx = ctx;
                bestIsStreaming = isStreaming;
                bestTs = null;
              }
            }

            if (remainder.length > 8192) remainder = remainder.slice(-8192);
          }

          if (bestCtx) {
            updateLastFromContext(bestCtx, bestIsStreaming, bestTs);
          }
        } finally {
          try {
            fs.closeSync(fd);
          } catch {}
        }
      } catch {
        // ignore
      } finally {
        reseedInProgress = false;
        if (reseedQueued) {
          reseedQueued = false;
          seedLastContextFromLog({ maxScanBytes, preferStreaming });
          return;
        }
        renderNow();
      }
    }, 0).unref();
  }

  // Seed prompt-context usage from existing logs (important for resumed sessions).
  // Do this asynchronously to avoid delaying the first statusline frame.
  let initialSeedDone = false;
  if (resumeFlag || resumeId) {
    initialSeedDone = true;
    seedLastContextFromLog({ maxScanBytes: 64 * 1024 * 1024, preferStreaming: true });
  }

  // Watch session settings for autonomy/reasoning changes (cheap polling with mtime).
  let settingsMtimeMs = 0;
  let lastCtxPollMs = 0;
  setInterval(() => {
    // Refresh config/global settings if they changed (model display depends on these).
    const configMtime = safeStatMtimeMs(CONFIG_PATH);
    if (configMtime && configMtime !== configMtimeMs) {
      configMtimeMs = configMtime;
      factoryConfig = readJsonFile(CONFIG_PATH) || {};
      refreshModel();
    }

    const globalMtime = safeStatMtimeMs(GLOBAL_SETTINGS_PATH);
    if (globalMtime && globalMtime !== globalSettingsMtimeMs) {
      globalSettingsMtimeMs = globalMtime;
      globalSettingsModel = resolveGlobalSettingsModel();
      refreshModel();
    }

    try {
      const stat = fs.statSync(settingsPath);
      if (stat.mtimeMs === settingsMtimeMs) return;
      settingsMtimeMs = stat.mtimeMs;
      const next = readJsonFile(settingsPath) || {};
      sessionSettings = next;

      // Keep session token usage in sync (used by /status).
      if (next && typeof next.tokenUsage === 'object' && next.tokenUsage) {
        sessionUsage = next.tokenUsage;
      }

      // Keep model/provider in sync (model can change during a running session).
      refreshModel();

      const now = Date.now();
      if (now - lastRenderAt >= MIN_RENDER_INTERVAL_MS) {
        lastRenderAt = now;
        renderNow();
      }
    } catch {
      // ignore
    }
  }, 750).unref();

  // Fallback: periodically rescan log if context is still zero after startup.
  // This handles cases where tail misses early log entries.
  setInterval(() => {
    const now = Date.now();
    if (now - START_MS < 3000) return; // wait 3s after startup
    if (last.contextCount > 0 || last.cacheReadInputTokens > 0) return; // already have data
    if (now - lastCtxPollMs < 5000) return; // throttle to every 5s
    lastCtxPollMs = now;
    seedLastContextFromLog({ maxScanBytes: 4 * 1024 * 1024, preferStreaming: false });
  }, 2000).unref();

  function switchToSession(nextSessionId) {
    if (!nextSessionId || !isUuid(nextSessionId)) return;
    const nextLower = String(nextSessionId).toLowerCase();
    if (nextLower === sessionIdLower) return;

    sessionId = nextSessionId;
    sessionIdLower = nextLower;

    const resolved = resolveSessionSettings(workspaceDir, nextSessionId);
    settingsPath = resolved.settingsPath;
    sessionSettings = resolved.settings || {};

    sessionUsage =
      sessionSettings && typeof sessionSettings.tokenUsage === 'object' && sessionSettings.tokenUsage
        ? sessionSettings.tokenUsage
        : {};

    // Reset cached state for the new session.
    last = { cacheReadInputTokens: 0, contextCount: 0, outputTokens: 0 };
    lastContextMs = 0;
    ctxAvailable = false;
    ctxApprox = false;
	    ctxOverflow = false;
	    ctxOverrideUsedTokens = null;
	    pendingCompactionSuffixTokens = null;
	    pendingCompactionSummaryOutputTokens = null;
	    pendingCompactionSummaryTsMs = null;
	    modelIdFromLog = null;
	    compacting = false;
	    settingsMtimeMs = 0;
	    lastCtxPollMs = 0;

    refreshModel();
    renderNow();

    // Best-effort: if the new session already has Context lines in the log, seed quickly.
    seedLastContextFromLog({ maxScanBytes: 8 * 1024 * 1024, preferStreaming: false });
  }

  // Follow the Factory log and update based on session-scoped events.
  const tail = spawn('tail', ['-n', '0', '-F', LOG_PATH], {
    stdio: ['ignore', 'pipe', 'ignore'],
  });

  let buffer = '';
  tail.stdout.on('data', (chunk) => {
    buffer += String(chunk);
    while (true) {
      const idx = buffer.indexOf('\\n');
      if (idx === -1) break;
      const line = buffer.slice(0, idx).trimEnd();
      buffer = buffer.slice(idx + 1);

	      const tsMs = parseLineTimestampMs(line);
	      const lineSessionId = extractSessionIdFromLine(line);
	      const isSessionLine =
	        lineSessionId && String(lineSessionId).toLowerCase() === sessionIdLower;

	      if (compacting && line.includes('[Compaction] End') && line.includes('Context:')) {
	        const ctxIndex = line.indexOf('Context: ');
	        if (ctxIndex !== -1) {
	          const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
	          try {
	            const meta = JSON.parse(jsonStr);
	            const summaryOut = Number(meta?.summaryOutputTokens);
	            if (
	              meta?.eventType === 'compaction' &&
	              meta?.state === 'end' &&
	              Number.isFinite(summaryOut) &&
	              summaryOut >= 0
	            ) {
	              pendingCompactionSummaryOutputTokens = summaryOut;
	              if (tsMs != null) pendingCompactionSummaryTsMs = tsMs;
	            }
	          } catch {
	          }
	        }
	      }

	      // /compress (aka /compact) can create a new session ID. Follow it so ctx/model keep updating.
	      if (line.includes('oldSessionId') && line.includes('newSessionId') && line.includes('Context:')) {
	        const ctxIndex = line.indexOf('Context: ');
	        if (ctxIndex !== -1) {
          const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
          try {
            const meta = JSON.parse(jsonStr);
            const oldId = meta?.oldSessionId;
            const newId = meta?.newSessionId;
	            if (
	              isUuid(oldId) &&
	              isUuid(newId) &&
	              String(oldId).toLowerCase() === sessionIdLower &&
	              String(newId).toLowerCase() !== sessionIdLower
	            ) {
	              const suffixTokens = Number.isFinite(pendingCompactionSuffixTokens)
	                ? pendingCompactionSuffixTokens
	                : 0;
	              const summaryOutTokens = Number.isFinite(pendingCompactionSummaryOutputTokens)
	                ? pendingCompactionSummaryOutputTokens
	                : null;
	              const summaryTsMs = Number.isFinite(pendingCompactionSummaryTsMs) ? pendingCompactionSummaryTsMs : null;

	              // Save baseline before switching session (it persists across sessions)
	              const savedBaseline = baselineCacheReadInputTokens;

	              switchToSession(String(newId));

	              // For manual /compress, immediately set an estimated ctx value
	              // This ensures the statusline shows a reasonable value right after compression
	              if (summaryOutTokens != null && summaryOutTokens > 0) {
	                const prefix = savedBaseline > 0 ? savedBaseline : 0;
	                const est = prefix + suffixTokens + summaryOutTokens;
	                if (est > 0) {
	                  setCtxOverride(est, { tsMs: summaryTsMs != null ? summaryTsMs : tsMs, approx: true, overflow: false });
	                }
	              }

	              // Always attempt to get a more accurate estimate from the new session's jsonl
	              // This will read the compaction_state and estimate tokens from summaryText
	              // Note: we pass forceApply=true to override even if ctxOverrideUsedTokens is set,
	              // because the jsonl-based estimate may be more accurate
	              maybeApplyCompactSessionEstimate(String(newId), {
	                suffixTokens,
	                tsMs: summaryTsMs != null ? summaryTsMs : tsMs,
	                forceApply: true,
	              });
	              continue;
	            }
          } catch {
            // ignore
          }
        }
      }

      let compactionChanged = false;
      let compactionEnded = false;
      if (line.includes('[Compaction]')) {
        // Accept session-scoped compaction lines; allow end markers to clear even
        // if the line lacks a session id (some builds omit Context on end lines).
        // For manual /compress, [Compaction] End uses the NEW session ID, so we need
        // to also accept End markers when compacting is true and it's an End line.
        const isManualCompactionEnd = compacting &&
          line.includes('[Compaction] End') &&
          lineSessionId &&
          String(lineSessionId).toLowerCase() !== sessionIdLower;
        if (isSessionLine || (compacting && !lineSessionId) || isManualCompactionEnd) {
          const next = nextCompactionState(line, compacting);
          if (next !== compacting) {
            compacting = next;
            compactionChanged = true;
            if (!compacting) compactionEnded = true;
          }
        }
      }

      if (compactionChanged && compacting) {
        pendingCompactionSuffixTokens = null;
        pendingCompactionSummaryOutputTokens = null;
        pendingCompactionSummaryTsMs = null;
        // Compaction can start after a context-limit error. Ensure we display the latest
        // pre-compaction ctx by reseeding from log (tail can miss bursts).
        seedLastContextFromLog({ maxScanBytes: 8 * 1024 * 1024, preferStreaming: true });
      }

      if (compactionEnded) {
        // ctx usage changes dramatically after compaction, but the next Context line
        // can be delayed. Clear displayed ctx immediately to avoid showing stale numbers.
        last.cacheReadInputTokens = 0;
        last.contextCount = 0;
        ctxAvailable = false;
        ctxOverrideUsedTokens = null;
        ctxApprox = false;
        ctxOverflow = false;
        if (tsMs != null) lastContextMs = tsMs;
      }

      if (!line.includes('Context:')) {
        if (compactionChanged) {
          lastRenderAt = Date.now();
          renderNow();
        }
        if (compactionEnded) {
          // Compaction often completes between turns. Refresh ctx numbers promptly
          // by rescanning the most recent Context entry for this session.
          setTimeout(() => {
            seedLastContextFromLog({ maxScanBytes: 8 * 1024 * 1024, preferStreaming: false });
          }, 250).unref();
        }
        continue;
      }
      if (!isSessionLine) {
        if (compactionChanged) {
          lastRenderAt = Date.now();
          renderNow();
        }
        if (compactionEnded) {
          setTimeout(() => {
            seedLastContextFromLog({ maxScanBytes: 8 * 1024 * 1024, preferStreaming: false });
          }, 250).unref();
        }
        continue;
      }

      const ctxIndex = line.indexOf('Context: ');
      if (ctxIndex === -1) continue;
      const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
      let ctx;
      try {
        ctx = JSON.parse(jsonStr);
      } catch {
        if (compactionChanged) {
          lastRenderAt = Date.now();
          renderNow();
        }
        continue;
      }

      // Context usage can appear on multiple session-scoped log lines; update whenever present.
      // (Streaming is still the best source for outputTokens / LastOut.)
      updateLastFromContext(ctx, false, tsMs);

      maybeCaptureCompactionSuffix(line, ctx);
      maybeUpdateCtxFromContextLimitFailure(line, ctx, tsMs);
      maybeApplyPostCompactionEstimate(line, ctx, tsMs);

      // For new sessions: if this is the first valid Context line and ctx is still 0,
      // trigger a reseed to catch any earlier log entries we might have missed.
      if (!initialSeedDone && last.contextCount === 0) {
        initialSeedDone = true;
        setTimeout(() => {
          seedLastContextFromLog({ maxScanBytes: 8 * 1024 * 1024, preferStreaming: false });
        }, 100).unref();
      }

      if (line.includes('[Agent] Streaming result')) {
        updateLastFromContext(ctx, true, tsMs);
      }

      const now = Date.now();
      if (compactionChanged || now - lastRenderAt >= MIN_RENDER_INTERVAL_MS) {
        lastRenderAt = now;
        renderNow();
      }

      if (compactionEnded) {
        setTimeout(() => {
          seedLastContextFromLog({ maxScanBytes: 8 * 1024 * 1024, preferStreaming: false });
        }, 250).unref();
      }
    }
  });

  const stop = () => {
    try { tail.kill('SIGTERM'); } catch {}
    process.exit(0);
  };

  process.on('SIGTERM', stop);
  process.on('SIGINT', stop);
  process.on('SIGHUP', stop);
}

main().catch(() => {});
`;
}

function generateStatuslineWrapperScript(
  execTargetPath: string,
  monitorScriptPath: string,
  sessionsScriptPath?: string,
): string {
  return generateStatuslineWrapperScriptBun(execTargetPath, monitorScriptPath, sessionsScriptPath);
}

function generateStatuslineWrapperScriptBun(
  execTargetPath: string,
  monitorScriptPath: string,
  sessionsScriptPath?: string,
): string {
  const execTargetJson = JSON.stringify(execTargetPath);
  const monitorScriptJson = JSON.stringify(monitorScriptPath);
  const sessionsScriptJson = sessionsScriptPath ? JSON.stringify(sessionsScriptPath) : "null";

  // Notes:
  // - Requires Bun >= 1.3.5 (Bun.Terminal via Bun.spawn({ terminal }))
  // - Keep dependencies zero; this file is written as a standalone executable.
  return `#!/usr/bin/env bun
// Droid with Statusline (Bun PTY proxy)
// Auto-generated by droid-patch --statusline

const EXEC_TARGET = ${execTargetJson};
const STATUSLINE_MONITOR = ${monitorScriptJson};
const SESSIONS_SCRIPT = ${sessionsScriptJson};

const IS_APPLE_TERMINAL = process.env.TERM_PROGRAM === "Apple_Terminal";
const MIN_RENDER_INTERVAL_MS = IS_APPLE_TERMINAL ? 800 : 400;
const QUIET_MS = 50;
const FORCE_REPAINT_INTERVAL_MS = 2000;
const RESERVED_ROWS = 1;

const BYPASS_FLAGS = new Set(["--help", "-h", "--version", "-V"]);
const BYPASS_COMMANDS = new Set(["help", "version", "completion", "completions", "exec"]);

function shouldPassthrough(argv) {
  for (const a of argv) {
    if (a === "--") break;
    if (BYPASS_FLAGS.has(a)) return true;
  }
  let endOpts = false;
  let cmd = null;
  for (const a of argv) {
    if (a === "--") {
      endOpts = true;
      continue;
    }
    if (!endOpts && a.startsWith("-")) continue;
    cmd = a;
    break;
  }
  return cmd && BYPASS_COMMANDS.has(cmd);
}

function isSessionsCommand(argv) {
  for (const a of argv) {
    if (a === "--") return false;
    if (a === "--sessions") return true;
  }
  return false;
}

async function execPassthrough(argv) {
  const proc = Bun.spawn([EXEC_TARGET, ...argv], {
    stdin: "inherit",
    stdout: "inherit",
    stderr: "inherit",
  });
  const code = await proc.exited;
  process.exit(code ?? 0);
}

async function runSessions() {
  if (SESSIONS_SCRIPT) {
    const proc = Bun.spawn(["node", String(SESSIONS_SCRIPT)], {
      stdin: "inherit",
      stdout: "inherit",
      stderr: "inherit",
    });
    const code = await proc.exited;
    process.exit(code ?? 0);
  }
  process.stderr.write("[statusline] sessions script not found\\n");
  process.exit(1);
}

function writeStdout(s) {
  try {
    process.stdout.write(s);
  } catch {
    // ignore
  }
}

function termSize() {
  const rows = Number(process.stdout.rows || 24);
  const cols = Number(process.stdout.columns || 80);
  return { rows: Number.isFinite(rows) ? rows : 24, cols: Number.isFinite(cols) ? cols : 80 };
}

const ANSI_RE = /\\x1b\\[[0-9;]*m/g;
const RESET_SGR = "\\x1b[0m";

function visibleWidth(text) {
  return String(text || "").replace(ANSI_RE, "").length;
}

function clampAnsi(text, cols) {
  if (!cols || cols <= 0) return String(text || "");
  cols = cols > 1 ? cols - 1 : cols; // avoid last-column wrap
  if (cols < 10) return String(text || "");
  const s = String(text || "");
  let visible = 0;
  let i = 0;
  const out = [];
  while (i < s.length) {
    const ch = s[i];
    if (ch === "\\x1b") {
      const m = s.indexOf("m", i);
      if (m !== -1) {
        out.push(s.slice(i, m + 1));
        i = m + 1;
        continue;
      }
      out.push(ch);
      i += 1;
      continue;
    }
    if (visible >= cols) break;
    out.push(ch);
    i += 1;
    visible += 1;
  }
  if (i < s.length && cols >= 1) {
    if (visible >= cols) {
      if (out.length) out[out.length - 1] = "";
      else out.push("");
    } else {
      out.push("");
    }
    out.push(RESET_SGR);
  }
  return out.join("");
}

function splitSegments(text) {
  if (!text) return [];
  const s = String(text);
  const segments = [];
  let start = 0;
  while (true) {
    const idx = s.indexOf(RESET_SGR, start);
    if (idx === -1) {
      const tail = s.slice(start);
      if (tail) segments.push(tail);
      break;
    }
    const seg = s.slice(start, idx + RESET_SGR.length);
    if (seg) segments.push(seg);
    start = idx + RESET_SGR.length;
  }
  return segments;
}

function wrapSegments(segments, cols) {
  if (!segments || segments.length === 0) return [""];
  if (!cols || cols <= 0) return [segments.join("")];

  const lines = [];
  let cur = [];
  let curW = 0;

  for (let seg of segments) {
    let segW = visibleWidth(seg);
    if (segW <= 0) continue;

    if (cur.length === 0) {
      if (segW > cols) {
        seg = clampAnsi(seg, cols);
        segW = visibleWidth(seg);
      }
      cur = [seg];
      curW = segW;
      continue;
    }

    if (curW + segW <= cols) {
      cur.push(seg);
      curW += segW;
    } else {
      lines.push(cur.join(""));
      if (segW > cols) {
        seg = clampAnsi(seg, cols);
        segW = visibleWidth(seg);
      }
      cur = [seg];
      curW = segW;
    }
  }

  if (cur.length) lines.push(cur.join(""));
  return lines.length ? lines : [""];
}

class StatusRenderer {
  constructor() {
    this.raw = "";
    this.segments = [];
    this.lines = [""];
    this.activeReservedRows = RESERVED_ROWS;
    this.force = false;
    this.urgent = false;
    this.lastRenderMs = 0;
    this.lastChildOutMs = 0;
    this.cursorVisible = true;
  }
  noteChildOutput() {
    this.lastChildOutMs = Date.now();
  }
  setCursorVisible(v) {
    this.cursorVisible = !!v;
  }
  forceRepaint(urgent = false) {
    this.force = true;
    if (urgent) this.urgent = true;
  }
  setActiveReservedRows(n) {
    const v = Number(n || 1);
    this.activeReservedRows = Number.isFinite(v) ? Math.max(1, Math.trunc(v)) : 1;
  }
  setLine(line) {
    const next = String(line || "");
    if (next !== this.raw) {
      this.raw = next;
      this.segments = splitSegments(next);
      this.force = true;
    }
  }
  desiredReservedRows(physicalRows, cols, minReserved) {
    let rows = Number(physicalRows || 24);
    rows = Number.isFinite(rows) ? rows : 24;
    cols = Number(cols || 80);
    cols = Number.isFinite(cols) ? cols : 80;

    const maxReserved = Math.max(1, rows - 4);
    const segs = this.segments.length ? this.segments : (this.raw ? [this.raw] : []);
    let lines = segs.length ? wrapSegments(segs, cols) : [""];

    const needed = Math.min(lines.length, maxReserved);
    let desired = Math.max(Number(minReserved || 1), needed);
    desired = Math.min(desired, maxReserved);

    if (lines.length < desired) lines = new Array(desired - lines.length).fill("").concat(lines);
    if (lines.length > desired) lines = lines.slice(-desired);

    this.lines = lines;
    return desired;
  }
  clearReservedArea(physicalRows, cols, reservedRows, restoreRow = 1, restoreCol = 1) {
    let rows = Number(physicalRows || 24);
    rows = Number.isFinite(rows) ? rows : 24;
    cols = Number(cols || 80);
    cols = Number.isFinite(cols) ? cols : 80;
    let reserved = Number(reservedRows || 1);
    reserved = Number.isFinite(reserved) ? Math.max(1, Math.trunc(reserved)) : 1;

    reserved = Math.min(reserved, rows);
    const startRow = rows - reserved + 1;
    const parts = ["\\x1b[?2026h", "\\x1b[?25l", RESET_SGR];
    for (let i = 0; i < reserved; i++) parts.push("\\x1b[" + (startRow + i) + ";1H\\x1b[2K");
    parts.push("\\x1b[" + restoreRow + ";" + restoreCol + "H");
    parts.push(this.cursorVisible ? "\\x1b[?25h" : "\\x1b[?25l");
    parts.push("\\x1b[?2026l");
    writeStdout(parts.join(""));
  }
  render(physicalRows, cols, restoreRow = 1, restoreCol = 1) {
    if (!this.force) return;
    if (!this.raw) {
      this.force = false;
      this.urgent = false;
      return;
    }
    const now = Date.now();
    if (!this.urgent && now - this.lastRenderMs < MIN_RENDER_INTERVAL_MS) return;
    if (!this.urgent && QUIET_MS > 0 && now - this.lastChildOutMs < QUIET_MS) return;

    let rows = Number(physicalRows || 24);
    rows = Number.isFinite(rows) ? rows : 24;
    cols = Number(cols || 80);
    cols = Number.isFinite(cols) ? cols : 80;
    if (cols <= 0) cols = 80;

    const reserved = Math.max(1, Math.min(this.activeReservedRows, Math.max(1, rows - 4)));
    const startRow = rows - reserved + 1;
    const childRows = rows - reserved;

    let lines = this.lines.length ? this.lines.slice() : [""];
    if (lines.length < reserved) lines = new Array(reserved - lines.length).fill("").concat(lines);
    if (lines.length > reserved) lines = lines.slice(-reserved);

    const parts = ["\\x1b[?2026h", "\\x1b[?25l"];
    parts.push("\\x1b[1;" + childRows + "r");
    for (let i = 0; i < reserved; i++) {
      const row = startRow + i;
      const text = clampAnsi(lines[i], cols);
      parts.push("\\x1b[" + row + ";1H" + RESET_SGR + "\\x1b[2K");
      parts.push("\\x1b[" + row + ";1H" + text + RESET_SGR);
    }
    parts.push("\\x1b[" + restoreRow + ";" + restoreCol + "H");
    parts.push(this.cursorVisible ? "\\x1b[?25h" : "\\x1b[?25l");
    parts.push("\\x1b[?2026l");
    writeStdout(parts.join(""));

    this.lastRenderMs = now;
    this.force = false;
    this.urgent = false;
  }
  clear() {
    const { rows, cols } = termSize();
    this.clearReservedArea(rows, cols, Math.max(this.activeReservedRows, RESERVED_ROWS));
  }
}

class OutputRewriter {
  constructor() {
    this.buf = new Uint8Array(0);
  }
  feed(chunk, maxRow) {
    if (!chunk || chunk.length === 0) return chunk;
    const merged = new Uint8Array(this.buf.length + chunk.length);
    merged.set(this.buf, 0);
    merged.set(chunk, this.buf.length);
    this.buf = new Uint8Array(0);

    const out = [];
    let i = 0;

    const isFinal = (v) => v >= 0x40 && v <= 0x7e;

    while (i < merged.length) {
      const b = merged[i];
      if (b !== 0x1b) {
        out.push(b);
        i += 1;
        continue;
      }
      if (i + 1 >= merged.length) {
        this.buf = merged.slice(i);
        break;
      }
      const nxt = merged[i + 1];
      if (nxt !== 0x5b) {
        out.push(b);
        i += 1;
        continue;
      }

      let j = i + 2;
      while (j < merged.length && !isFinal(merged[j])) j += 1;
      if (j >= merged.length) {
        this.buf = merged.slice(i);
        break;
      }
      const final = merged[j];
      let seq = merged.slice(i, j + 1);

      if ((final === 0x48 || final === 0x66) && maxRow > 0) {
        const params = merged.slice(i + 2, j);
        const s = new TextDecoder().decode(params);
        if (!s || /^[0-9;]/.test(s)) {
          const parts = s ? s.split(";") : [];
          const row = Number(parts[0] || 1);
          const col = Number(parts[1] || 1);
          let r = Number.isFinite(row) ? row : 1;
          let c = Number.isFinite(col) ? col : 1;
          if (r === 999 || r > maxRow) r = maxRow;
          if (r < 1) r = 1;
          if (c < 1) c = 1;
          const newParams = new TextEncoder().encode(String(r) + ";" + String(c));
          const ns = new Uint8Array(2 + newParams.length + 1);
          ns[0] = 0x1b;
          ns[1] = 0x5b;
          ns.set(newParams, 2);
          ns[ns.length - 1] = final;
          seq = ns;
        }
      } else if (final === 0x72 && maxRow > 0) {
        const params = merged.slice(i + 2, j);
        const s = new TextDecoder().decode(params);
        if (!s || /^[0-9;]/.test(s)) {
          const parts = s ? s.split(";") : [];
          const top = Number(parts[0] || 1);
          const bottom = Number(parts[1] || maxRow);
          let t = Number.isFinite(top) ? top : 1;
          let btm = Number.isFinite(bottom) ? bottom : maxRow;
          if (t <= 0) t = 1;
          if (btm <= 0 || btm === 999 || btm > maxRow) btm = maxRow;
          if (t > btm) t = 1;
          const str = "\\x1b[" + String(t) + ";" + String(btm) + "r";
          seq = new TextEncoder().encode(str);
        }
      }

      for (const bb of seq) out.push(bb);
      i = j + 1;
    }

    return new Uint8Array(out);
  }
}

class CursorTracker {
  constructor() {
    this.row = 1;
    this.col = 1;
    this.savedRow = 1;
    this.savedCol = 1;
    this.buf = new Uint8Array(0);
    this.inOsc = false;
    this.utf8Cont = 0;
    this.wrapPending = false;
  }
  position() {
    return { row: this.row, col: this.col };
  }
  feed(chunk, maxRow, maxCol) {
    if (!chunk || chunk.length === 0) return;
    maxRow = Math.max(1, Number(maxRow || 1));
    maxCol = Math.max(1, Number(maxCol || 1));

    const merged = new Uint8Array(this.buf.length + chunk.length);
    merged.set(this.buf, 0);
    merged.set(chunk, this.buf.length);
    this.buf = new Uint8Array(0);

    const clamp = () => {
      if (this.row < 1) this.row = 1;
      else if (this.row > maxRow) this.row = maxRow;
      if (this.col < 1) this.col = 1;
      else if (this.col > maxCol) this.col = maxCol;
    };

    const parseIntDefault = (v, d) => {
      const n = Number(v);
      return Number.isFinite(n) && n > 0 ? Math.trunc(n) : d;
    };

    let i = 0;
    const isFinal = (v) => v >= 0x40 && v <= 0x7e;

    while (i < merged.length) {
      const b = merged[i];

      if (this.inOsc) {
        if (b === 0x07) {
          this.inOsc = false;
          i += 1;
          continue;
        }
        if (b === 0x1b) {
          if (i + 1 >= merged.length) {
            this.buf = merged.slice(i);
            break;
          }
          if (merged[i + 1] === 0x5c) {
            this.inOsc = false;
            i += 2;
            continue;
          }
        }
        i += 1;
        continue;
      }

      if (this.utf8Cont > 0) {
        if (b >= 0x80 && b <= 0xbf) {
          this.utf8Cont -= 1;
          i += 1;
          continue;
        }
        this.utf8Cont = 0;
      }

      if (b === 0x1b) {
        this.wrapPending = false;
        if (i + 1 >= merged.length) {
          this.buf = merged.slice(i);
          break;
        }
        const nxt = merged[i + 1];

        if (nxt === 0x5b) {
          let j = i + 2;
          while (j < merged.length && !isFinal(merged[j])) j += 1;
          if (j >= merged.length) {
            this.buf = merged.slice(i);
            break;
          }
          const final = merged[j];
          const params = merged.slice(i + 2, j);
          const s = new TextDecoder().decode(params);
          if (s && !/^[0-9;]/.test(s)) {
            i = j + 1;
            continue;
          }
          const parts = s ? s.split(";") : [];
          const p0 = parseIntDefault(parts[0] || "", 1);
          const p1 = parseIntDefault(parts[1] || "", 1);

          if (final === 0x48 || final === 0x66) {
            this.row = p0;
            this.col = p1;
            clamp();
          } else if (final === 0x41) {
            this.row = Math.max(1, this.row - p0);
          } else if (final === 0x42) {
            this.row = Math.min(maxRow, this.row + p0);
          } else if (final === 0x43) {
            this.col = Math.min(maxCol, this.col + p0);
          } else if (final === 0x44) {
            this.col = Math.max(1, this.col - p0);
          } else if (final === 0x45) {
            this.row = Math.min(maxRow, this.row + p0);
            this.col = 1;
          } else if (final === 0x46) {
            this.row = Math.max(1, this.row - p0);
            this.col = 1;
          } else if (final === 0x47) {
            this.col = p0;
            clamp();
          } else if (final === 0x64) {
            this.row = p0;
            clamp();
          } else if (final === 0x72) {
            this.row = 1;
            this.col = 1;
          } else if (final === 0x73) {
            this.savedRow = this.row;
            this.savedCol = this.col;
          } else if (final === 0x75) {
            this.row = this.savedRow;
            this.col = this.savedCol;
            clamp();
          }

          i = j + 1;
          continue;
        }

        if (nxt === 0x5d || nxt === 0x50 || nxt === 0x5e || nxt === 0x5f || nxt === 0x58) {
          this.inOsc = true;
          i += 2;
          continue;
        }

        if (nxt === 0x37) {
          this.savedRow = this.row;
          this.savedCol = this.col;
          i += 2;
          continue;
        }
        if (nxt === 0x38) {
          this.row = this.savedRow;
          this.col = this.savedCol;
          clamp();
          i += 2;
          continue;
        }

        i += 2;
        continue;
      }

      if (b === 0x0d) {
        this.col = 1;
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b === 0x0a || b === 0x0b || b === 0x0c) {
        this.row = Math.min(maxRow, this.row + 1);
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b === 0x08) {
        this.col = Math.max(1, this.col - 1);
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b === 0x09) {
        const nextStop = Math.floor((this.col - 1) / 8 + 1) * 8 + 1;
        this.col = Math.min(maxCol, nextStop);
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b < 0x20 || b === 0x7f) {
        i += 1;
        continue;
      }

      if (this.wrapPending) {
        this.row = Math.min(maxRow, this.row + 1);
        this.col = 1;
        this.wrapPending = false;
      }

      if (b >= 0x80) {
        if ((b & 0xe0) === 0xc0) this.utf8Cont = 1;
        else if ((b & 0xf0) === 0xe0) this.utf8Cont = 2;
        else if ((b & 0xf8) === 0xf0) this.utf8Cont = 3;
        else this.utf8Cont = 0;
      }

      if (this.col < maxCol) this.col += 1;
      else {
        this.col = maxCol;
        this.wrapPending = true;
      }
      i += 1;
    }
  }
}

async function main() {
  const argv = process.argv.slice(2);

  if (isSessionsCommand(argv)) await runSessions();

  if (!process.stdin.isTTY || !process.stdout.isTTY || shouldPassthrough(argv)) {
    await execPassthrough(argv);
    return;
  }

  // Clean viewport.
  writeStdout("\\x1b[?2026h\\x1b[0m\\x1b[r\\x1b[2J\\x1b[H\\x1b[?2026l");

  const renderer = new StatusRenderer();
  renderer.setLine("\\x1b[48;5;238m\\x1b[38;5;15m Statusline: starting \\x1b[0m");
  renderer.forceRepaint(true);

  let { rows: physicalRows, cols: physicalCols } = termSize();
  let effectiveReservedRows = renderer.desiredReservedRows(physicalRows, physicalCols, RESERVED_ROWS);
  renderer.setActiveReservedRows(effectiveReservedRows);
  let childRows = Math.max(4, physicalRows - effectiveReservedRows);
  let childCols = Math.max(10, physicalCols);

  // Reserve the bottom rows early, before the child starts writing.
  writeStdout(
    "\\x1b[?2026h\\x1b[?25l\\x1b[1;" + childRows + "r\\x1b[1;1H\\x1b[?25h\\x1b[?2026l",
  );
  renderer.forceRepaint(true);
  renderer.render(physicalRows, physicalCols, 1, 1);

  // Spawn child with terminal support.
  let child;
  try {
    child = Bun.spawn([EXEC_TARGET, ...argv], {
      cwd: process.cwd(),
      env: process.env,
      detached: true,
      terminal: {
        cols: childCols,
        rows: childRows,
        data(_terminal, data) {
          onChildData(data);
        },
      },
      onExit(_proc, exitCode, signal, _error) {
        onChildExit(exitCode, signal);
      },
    });
  } catch (e) {
    process.stderr.write("[statusline] failed to spawn child: " + String(e?.message || e) + "\\n");
    process.exit(1);
  }

  const terminal = child.terminal;

  // Best-effort PGID resolution (matches Python wrapper behavior).
  // This improves session resolution (ps/lsof scanning) and signal forwarding.
  let pgid = child.pid;
  try {
    const res = Bun.spawnSync(["ps", "-o", "pgid=", "-p", String(child.pid)], {
      stdin: "ignore",
      stdout: "pipe",
      stderr: "ignore",
    });
    if (res && res.exitCode === 0 && res.stdout) {
      const text = new TextDecoder().decode(res.stdout).trim();
      const n = Number(text);
      if (Number.isFinite(n) && n > 0) pgid = Math.trunc(n);
    }
  } catch {}

  // Spawn monitor (Node).
  const monitorEnv = { ...process.env, DROID_STATUSLINE_PGID: String(pgid) };
  const monitor = Bun.spawn(["node", STATUSLINE_MONITOR, ...argv], {
    stdin: "ignore",
    stdout: "pipe",
    stderr: "ignore",
    env: monitorEnv,
  });

  let shouldStop = false;
  const rewriter = new OutputRewriter();
  const cursor = new CursorTracker();

  let detectBuf = new Uint8Array(0);
  let detectStr = "";
  let cursorVisible = true;
  let scrollRegionDirty = true;
  let lastForceRepaintMs = Date.now();
  let lastPhysicalRows = 0;
  let lastPhysicalCols = 0;

  function appendDetect(chunk) {
    const max = 128;
    const merged = new Uint8Array(Math.min(max, detectBuf.length + chunk.length));
    const takePrev = Math.max(0, merged.length - chunk.length);
    if (takePrev > 0) merged.set(detectBuf.slice(Math.max(0, detectBuf.length - takePrev)), 0);
    merged.set(chunk.slice(Math.max(0, chunk.length - (merged.length - takePrev))), takePrev);
    detectBuf = merged;
    try {
      detectStr = Buffer.from(detectBuf).toString("latin1");
    } catch {
      detectStr = "";
    }
  }

  function includesBytes(needle) {
    return detectStr.includes(needle);
  }

  function lastIndexOfBytes(needle) {
    return detectStr.lastIndexOf(needle);
  }

  function includesScrollRegionCSI() {
    return /\\x1b\\[[0-9]*;?[0-9]*r/.test(detectStr);
  }

  function updateCursorVisibility() {
    const show = includesBytes("\\x1b[?25h");
    const hide = includesBytes("\\x1b[?25l");
    if (show || hide) {
      // best-effort: if both present, whichever appears later "wins"
      const h = lastIndexOfBytes("\\x1b[?25h");
      const l = lastIndexOfBytes("\\x1b[?25l");
      cursorVisible = h > l;
      renderer.setCursorVisible(cursorVisible);
    }
  }

  function needsScrollRegionReset() {
    return (
      includesBytes("\\x1b[?1049") ||
      includesBytes("\\x1b[?1047") ||
      includesBytes("\\x1b[?47") ||
      includesBytes("\\x1b[J") ||
      includesBytes("\\x1b[0J") ||
      includesBytes("\\x1b[1J") ||
      includesBytes("\\x1b[2J") ||
      includesBytes("\\x1b[3J") ||
      includesBytes("\\x1b[r") ||
      includesScrollRegionCSI()
    );
  }

  function onChildData(data) {
    if (shouldStop) return;
    const chunk = data instanceof Uint8Array ? data : new Uint8Array(data);
    appendDetect(chunk);
    if (needsScrollRegionReset()) scrollRegionDirty = true;
    updateCursorVisibility();

    renderer.noteChildOutput();
    const rewritten = rewriter.feed(chunk, childRows);
    cursor.feed(rewritten, childRows, childCols);
    writeStdout(Buffer.from(rewritten));
  }

  let cleanupCalled = false;
  function onChildExit(exitCode, signal) {
    shouldStop = true;
    if (cleanupCalled) return;
    cleanupCalled = true;
    const code = exitCode ?? (signal != null ? 128 + signal : 0);
    cleanup().finally(() => process.exit(code));
  }

  async function readMonitor() {
    if (!monitor.stdout) return;
    const reader = monitor.stdout.getReader();
    let buf = "";
    while (!shouldStop) {
      const { value, done } = await reader.read();
      if (done || !value) break;
      buf += new TextDecoder().decode(value);
      while (true) {
        const idx = buf.indexOf("\\n");
        if (idx === -1) break;
        const line = buf.slice(0, idx).replace(/\\r$/, "");
        buf = buf.slice(idx + 1);
        if (!line) continue;
        renderer.setLine(line);
        renderer.forceRepaint(false);
      }
    }
  }
  readMonitor().catch(() => {});

  function repaintStatusline(forceUrgent = false) {
    const { row, col } = cursor.position();
    let r = Math.max(1, Math.min(childRows, row));
    let c = Math.max(1, Math.min(childCols, col));

    if (scrollRegionDirty) {
      const seq =
        "\\x1b[?2026h\\x1b[?25l\\x1b[1;" +
        childRows +
        "r\\x1b[" +
        r +
        ";" +
        c +
        "H" +
        (cursorVisible ? "\\x1b[?25h" : "\\x1b[?25l") +
        "\\x1b[?2026l";
      writeStdout(seq);
      scrollRegionDirty = false;
    }

    renderer.forceRepaint(forceUrgent);
    renderer.render(physicalRows, physicalCols, r, c);
  }

  function handleSizeChange(nextRows, nextCols, forceUrgent = false) {
    physicalRows = nextRows;
    physicalCols = nextCols;

    const desired = renderer.desiredReservedRows(physicalRows, physicalCols, RESERVED_ROWS);
    const { row, col } = cursor.position();
    if (desired < effectiveReservedRows) {
      renderer.clearReservedArea(physicalRows, physicalCols, effectiveReservedRows, row, col);
    }
    effectiveReservedRows = desired;
    renderer.setActiveReservedRows(effectiveReservedRows);

    childRows = Math.max(4, physicalRows - effectiveReservedRows);
    childCols = Math.max(10, physicalCols);
    try {
      terminal.resize(childCols, childRows);
    } catch {}
    try {
      process.kill(-child.pid, "SIGWINCH");
    } catch {
      try { process.kill(child.pid, "SIGWINCH"); } catch {}
    }

    scrollRegionDirty = true;
    renderer.forceRepaint(true);
    repaintStatusline(forceUrgent);
  }

  process.on("SIGWINCH", () => {
    const next = termSize();
    handleSizeChange(next.rows, next.cols, true);
  });

  // Forward signals to child's process group when possible.
  const forward = (sig) => {
    // Stop processing child output before forwarding signal
    // This prevents the child's cleanup/clear screen sequences from being written
    shouldStop = true;
    try {
      process.kill(-pgid, sig);
    } catch {
      try {
        process.kill(child.pid, sig);
      } catch {}
    }
  };
  for (const s of ["SIGTERM", "SIGINT", "SIGHUP"]) {
    try {
      process.on(s, () => forward(s));
    } catch {}
  }

  // Raw stdin -> PTY.
  try {
    process.stdin.setRawMode(true);
  } catch {}
  process.stdin.resume();
  process.stdin.on("data", (buf) => {
    try {
      if (typeof buf === "string") terminal.write(buf);
      else {
        // Prefer bytes when supported; fall back to UTF-8 decoding.
        try {
          // Bun.Terminal.write may accept Uint8Array in newer versions.
          terminal.write(buf);
        } catch {
          terminal.write(new TextDecoder().decode(buf));
        }
      }
    } catch {}
  });

  const tick = setInterval(() => {
    if (shouldStop) return;
    const next = termSize();
    const sizeChanged = next.rows !== lastPhysicalRows || next.cols !== lastPhysicalCols;
    const desired = renderer.desiredReservedRows(next.rows, next.cols, RESERVED_ROWS);
    if (sizeChanged || desired !== effectiveReservedRows) {
      handleSizeChange(next.rows, next.cols, true);
      lastPhysicalRows = next.rows;
      lastPhysicalCols = next.cols;
      lastForceRepaintMs = Date.now();
      return;
    }
    const now = Date.now();
    if (now - lastForceRepaintMs >= FORCE_REPAINT_INTERVAL_MS) {
      repaintStatusline(false);
      lastForceRepaintMs = now;
    } else {
      const { row, col } = cursor.position();
      renderer.render(physicalRows, physicalCols, row, col);
    }
  }, 50);

  async function cleanup() {
    clearInterval(tick);
    try {
      process.stdin.setRawMode(false);
    } catch {}
    // Don't clear screen or reset scroll region on exit - preserve session ID and logs
    // Only reset colors and show cursor
    try {
      writeStdout("\\x1b[0m\\x1b[?25h");
    } catch {}
    try {
      monitor.kill();
    } catch {}
    try {
      terminal.close();
    } catch {}
  }

  // Keep process alive until child exits.
  await child.exited;
  await cleanup();
}

main().catch(() => process.exit(1));
`;
}

export async function createStatuslineFiles(
  outputDir: string,
  execTargetPath: string,
  aliasName: string,
  sessionsScriptPath?: string,
): Promise<{ wrapperScript: string; monitorScript: string }> {
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const monitorScriptPath = join(outputDir, `${aliasName}-statusline.js`);
  const wrapperScriptPath = join(outputDir, aliasName);

  await writeFile(monitorScriptPath, generateStatuslineMonitorScript());
  await chmod(monitorScriptPath, 0o755);

  const wrapper = generateStatuslineWrapperScript(
    execTargetPath,
    monitorScriptPath,
    sessionsScriptPath,
  );

  await writeFile(wrapperScriptPath, wrapper);
  await chmod(wrapperScriptPath, 0o755);

  return { wrapperScript: wrapperScriptPath, monitorScript: monitorScriptPath };
}
