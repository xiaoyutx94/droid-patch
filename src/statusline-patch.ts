import { chmod, mkdir, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join } from "node:path";

function generateStatuslineMonitorScript(): string {
  // Keep this script dependency-free (Node built-ins only). It runs from the wrapper via `node`.
  return `#!/usr/bin/env node
/* Auto-generated by droid-patch --statusline */

const fs = require('fs');
const os = require('os');
const path = require('path');
const { spawn, spawnSync } = require('child_process');

// This monitor does NOT draw directly to the terminal. It emits newline-delimited
// statusline frames to stdout. A wrapper (PTY proxy) is responsible for rendering
// the latest frame on a reserved bottom row to avoid flicker.

const FACTORY_HOME = path.join(os.homedir(), '.factory');

const SESSIONS_ROOT = path.join(FACTORY_HOME, 'sessions');
const LOG_PATH = path.join(FACTORY_HOME, 'logs', 'droid-log-single.log');
const CONFIG_PATH = path.join(FACTORY_HOME, 'config.json');
const GLOBAL_SETTINGS_PATH = path.join(FACTORY_HOME, 'settings.json');

const IS_APPLE_TERMINAL = process.env.TERM_PROGRAM === 'Apple_Terminal';
const MIN_RENDER_INTERVAL_MS = IS_APPLE_TERMINAL ? 1000 : 500;

const START_MS = Date.now();
const ARGS = process.argv.slice(2);
const PGID = Number(process.env.DROID_STATUSLINE_PGID || '');
const SESSION_ID_RE = /"sessionId":"([0-9a-f-]{36})"/i;

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function isPositiveInt(n) {
  return Number.isFinite(n) && n > 0;
}

function extractSessionIdFromLine(line) {
  if (!line) return null;
  const m = String(line).match(SESSION_ID_RE);
  return m ? m[1] : null;
}

function nextCompactionState(line, current) {
  if (!line) return current;
  if (line.includes('[Compaction] Start')) return true;
  if (
    line.includes('[Compaction] End') ||
    line.includes('[Compaction] Done') ||
    line.includes('[Compaction] Finish') ||
    line.includes('[Compaction] Finished') ||
    line.includes('[Compaction] Complete') ||
    line.includes('[Compaction] Completed')
  ) {
    return false;
  }
  return current;
}

function firstNonNull(promises) {
  const list = Array.isArray(promises) ? promises : [];
  if (list.length === 0) return Promise.resolve(null);
  return new Promise((resolve) => {
    let pending = list.length;
    let done = false;
    for (const p of list) {
      Promise.resolve(p)
        .then((value) => {
          if (done) return;
          if (value) {
            done = true;
            resolve(value);
            return;
          }
          pending -= 1;
          if (pending <= 0) resolve(null);
        })
        .catch(() => {
          if (done) return;
          pending -= 1;
          if (pending <= 0) resolve(null);
        });
    }
  });
}

function listPidsInProcessGroup(pgid) {
  if (!isPositiveInt(pgid)) return [];
  try {
    const res = spawnSync('ps', ['-ax', '-o', 'pid=,pgid='], {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (!res || res.status !== 0) return [];
    const out = String(res.stdout || '');
    const pids = [];
    for (const line of out.split('\\n')) {
      const parts = line.trim().split(/\\s+/);
      if (parts.length < 2) continue;
      const pid = Number(parts[0]);
      const g = Number(parts[1]);
      if (Number.isFinite(pid) && g === pgid) pids.push(pid);
    }
    return pids;
  } catch {
    return [];
  }
}

function resolveOpenSessionFromPids(pids) {
  if (!Array.isArray(pids) || pids.length === 0) return null;
  // lsof prints file names as lines prefixed with "n" when using -Fn
  try {
    const res = spawnSync('lsof', ['-p', pids.join(','), '-Fn'], {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 1200,
    });
    if (!res || res.status !== 0) return null;
    const out = String(res.stdout || '');
    for (const line of out.split('\\n')) {
      if (!line || line[0] !== 'n') continue;
      const name = line.slice(1);
      if (!name.startsWith(SESSIONS_ROOT + path.sep)) continue;
      const m = name.match(/([0-9a-f-]{36})\\.(jsonl|settings\\.json)$/i);
      if (!m) continue;
      const id = m[1];
      const workspaceDir = path.dirname(name);
      if (path.dirname(workspaceDir) !== SESSIONS_ROOT) continue;
      return { workspaceDir, id };
    }
  } catch {
    return null;
  }
  return null;
}

async function resolveSessionFromProcessGroup(shouldAbort, maxTries = 20) {
  if (!isPositiveInt(PGID)) return null;
  // Wait a little for droid to create/open the session files.
  for (let i = 0; i < maxTries; i++) {
    if (shouldAbort && shouldAbort()) return null;
    const pids = listPidsInProcessGroup(PGID);
    const found = resolveOpenSessionFromPids(pids);
    if (found) return found;
    await sleep(100);
  }
  return null;
}

function safeReadFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch {
    return null;
  }
}

function safeJsonParse(text) {
  if (!text) return null;
  try {
    // Factory settings/config files can contain comments. Strip them safely without
    // breaking URLs like "http://..." which contain "//" inside strings.
    const stripComments = (input) => {
      let out = '';
      let inString = false;
      let escape = false;
      for (let i = 0; i < input.length; i++) {
        const ch = input[i];
        const next = input[i + 1];

        if (inString) {
          out += ch;
          if (escape) {
            escape = false;
            continue;
          }
          if (ch === '\\\\') {
            escape = true;
            continue;
          }
          if (ch === '"') {
            inString = false;
          }
          continue;
        }

        if (ch === '"') {
          inString = true;
          out += ch;
          continue;
        }

        // Line comment
        if (ch === '/' && next === '/') {
          while (i < input.length && input[i] !== '\\n') i++;
          out += '\\n';
          continue;
        }

        // Block comment
        if (ch === '/' && next === '*') {
          i += 2;
          while (i < input.length && !(input[i] === '*' && input[i + 1] === '/')) i++;
          i += 1;
          continue;
        }

        out += ch;
      }
      return out;
    };

    return JSON.parse(stripComments(text));
  } catch {
    return null;
  }
}

function readJsonFile(filePath) {
  return safeJsonParse(safeReadFile(filePath));
}

function isUuid(text) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(text);
}

function parseResume(args) {
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '-r' || a === '--resume') {
      const next = args[i + 1];
      if (next && isUuid(next)) return { resumeFlag: true, resumeId: next };
      return { resumeFlag: true, resumeId: null };
    }
    if (a.startsWith('--resume=')) {
      const value = a.slice('--resume='.length);
      return { resumeFlag: true, resumeId: isUuid(value) ? value : null };
    }
  }
  return { resumeFlag: false, resumeId: null };
}

function sanitizeWorkspaceDirName(cwd) {
  return String(cwd)
    .replace(/[:]/g, '')
    .replace(/[\\\\/]/g, '-')
    .replace(/\\s+/g, '-');
}

function listSessionCandidates(workspaceDir) {
  let files = [];
  try {
    files = fs.readdirSync(workspaceDir);
  } catch {
    return [];
  }
  const candidates = [];
  for (const file of files) {
    const m = file.match(/^([0-9a-f-]{36})\\.(jsonl|settings\\.json)$/i);
    if (!m) continue;
    const id = m[1];
    const fullPath = path.join(workspaceDir, file);
    try {
      const stat = fs.statSync(fullPath);
      candidates.push({ id, fullPath, mtimeMs: stat.mtimeMs });
    } catch {
      // ignore
    }
  }
  return candidates;
}

function findWorkspaceDirForSessionId(workspaceDirs, sessionId) {
  for (const dir of workspaceDirs) {
    try {
      const settingsPath = path.join(dir, sessionId + '.settings.json');
      if (fs.existsSync(settingsPath)) return dir;
    } catch {
      // ignore
    }
  }
  return null;
}

function pickLatestSessionAcross(workspaceDirs) {
  let best = null;
  for (const dir of workspaceDirs) {
    const candidates = listSessionCandidates(dir);
    for (const c of candidates) {
      if (!best || c.mtimeMs > best.mtimeMs) {
        best = { workspaceDir: dir, id: c.id, mtimeMs: c.mtimeMs };
      }
    }
  }
  return best ? { workspaceDir: best.workspaceDir, id: best.id } : null;
}

async function waitForNewSessionAcross(workspaceDirs, knownIdsByWorkspace, startMs, shouldAbort) {
  for (let i = 0; i < 80; i++) {
    if (shouldAbort && shouldAbort()) return null;
    let best = null;
    for (const dir of workspaceDirs) {
      const known = knownIdsByWorkspace.get(dir) || new Set();
      const candidates = listSessionCandidates(dir);
      for (const c of candidates) {
        if (!(c.mtimeMs >= startMs - 50 || !known.has(c.id))) continue;
        if (!best || c.mtimeMs > best.mtimeMs) {
          best = { workspaceDir: dir, id: c.id, mtimeMs: c.mtimeMs };
        }
      }
    }
    if (best?.id) return { workspaceDir: best.workspaceDir, id: best.id };
    await sleep(100);
  }
  return null;
}

function safeRealpath(p) {
  try {
    return fs.realpathSync(p);
  } catch {
    return null;
  }
}

function resolveWorkspaceDirs(cwd) {
  const logical = cwd;
  const real = safeRealpath(cwd);
  const dirs = [];
  for (const value of [logical, real]) {
    if (!value || typeof value !== 'string') continue;
    dirs.push(path.join(SESSIONS_ROOT, sanitizeWorkspaceDirName(value)));
  }
  return Array.from(new Set(dirs));
}

function resolveSessionSettings(workspaceDir, sessionId) {
  const settingsPath = path.join(workspaceDir, sessionId + '.settings.json');
  const settings = readJsonFile(settingsPath) || {};
  return { settingsPath, settings };
}

function resolveGlobalSettingsModel() {
  const global = readJsonFile(GLOBAL_SETTINGS_PATH);
  return global && typeof global.model === 'string' ? global.model : null;
}

function resolveCustomModelIndex(modelId) {
  if (typeof modelId !== 'string') return null;
  if (!modelId.startsWith('custom:')) return null;
  const m = modelId.match(/-(\\d+)$/);
  if (!m) return null;
  const idx = Number(m[1]);
  return Number.isFinite(idx) ? idx : null;
}

function resolveUnderlyingModelId(modelId, factoryConfig) {
  const idx = resolveCustomModelIndex(modelId);
  if (idx == null) return modelId;
  const entry = factoryConfig?.custom_models?.[idx];
  if (entry && typeof entry.model === 'string') return entry.model;
  return modelId;
}

function resolveProvider(modelId, factoryConfig) {
  const idx = resolveCustomModelIndex(modelId);
  if (idx != null) {
    const entry = factoryConfig?.custom_models?.[idx];
    if (entry && typeof entry.provider === 'string') return entry.provider;
  }
  if (typeof modelId === 'string' && modelId.startsWith('claude-')) return 'anthropic';
  return '';
}

function formatInt(n) {
  if (!Number.isFinite(n)) return '0';
  return Math.round(n).toString();
}

function formatTokens(n) {
  if (!Number.isFinite(n)) return '0';
  const sign = n < 0 ? '-' : '';
  const abs = Math.abs(n);
  if (abs >= 1_000_000) {
    const v = abs / 1_000_000;
    const s = v >= 10 ? v.toFixed(0) : v.toFixed(1);
    return sign + s.replace(/\\.0$/, '') + 'M';
  }
  if (abs >= 10_000) {
    const v = abs / 1_000;
    const s = v >= 100 ? v.toFixed(0) : v.toFixed(1);
    return sign + s.replace(/\\.0$/, '') + 'k';
  }
  return sign + Math.round(abs).toString();
}

function emitFrame(line) {
  try {
    process.stdout.write(String(line || '') + '\\n');
  } catch {
    // ignore
  }
}

function seg(bg, fg, text) {
  if (!text) return '';
  return '\\x1b[48;5;' + bg + 'm' + '\\x1b[38;5;' + fg + 'm' + ' ' + text + ' ' + '\\x1b[0m';
}

function resolveGitBranch(cwd) {
  try {
    const res = spawnSync('git', ['rev-parse', '--abbrev-ref', 'HEAD'], {
      cwd,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (res && res.status === 0) {
      const branch = String(res.stdout || '').trim();
      if (branch && branch !== 'HEAD') return branch;
    }
  } catch {}
  try {
    const headPath = path.join(cwd, '.git', 'HEAD');
    const head = safeReadFile(headPath);
    if (head && head.startsWith('ref: ')) {
      const ref = head.slice('ref: '.length).trim();
      const m = ref.match(/refs\\/heads\\/(.+)$/);
      if (m) return m[1];
    }
  } catch {}
  return '';
}

function resolveGitDiffSummary(cwd) {
  try {
    const res = spawnSync('git', ['diff', '--shortstat'], {
      cwd,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (!res || res.status !== 0) return '';
    const text = String(res.stdout || '').trim();
    if (!text) return '';
    const ins = (text.match(/(\\d+)\\sinsertions?\\(\\+\\)/) || [])[1];
    const del = (text.match(/(\\d+)\\sdeletions?\\(-\\)/) || [])[1];
    const i = ins ? Number(ins) : 0;
    const d = del ? Number(del) : 0;
    if (!Number.isFinite(i) && !Number.isFinite(d)) return '';
    if (i === 0 && d === 0) return '';
    return '(+' + formatInt(i) + ',-' + formatInt(d) + ')';
  } catch {
    return '';
  }
}

function buildLine(params) {
  const {
    provider,
    model,
    cwdBase,
    gitBranch,
    gitDiff,
    usedTokens,
    cacheRead,
    deltaInput,
    lastOutputTokens,
    sessionUsage,
    compacting,
  } = params;

  let ctxPart = 'Ctx: ' + formatTokens(usedTokens);

  const cachePart =
    cacheRead > 0 || deltaInput > 0
      ? ' c' + formatTokens(cacheRead) + '+n' + formatTokens(deltaInput)
      : '';

  const compactPart = compacting ? ' COMPACT' : '';

  const usagePart = (() => {
    const u = sessionUsage || {};
    const input = Number(u.inputTokens ?? 0);
    const output = Number(u.outputTokens ?? 0);
    const cacheCreation = Number(u.cacheCreationTokens ?? 0);
    const cacheReadTotal = Number(u.cacheReadTokens ?? 0);
    const thinking = Number(u.thinkingTokens ?? 0);
    if (!(input || output || cacheCreation || cacheReadTotal || thinking)) return '';
    const parts = [];
    if (input) parts.push('In:' + formatTokens(input));
    if (output) parts.push('Out:' + formatTokens(output));
    if (cacheCreation) parts.push('Cre:' + formatTokens(cacheCreation));
    if (cacheReadTotal) parts.push('Read:' + formatTokens(cacheReadTotal));
    if (thinking) parts.push('Think:' + formatTokens(thinking));
    if (lastOutputTokens > 0) parts.push('LastOut:' + formatTokens(lastOutputTokens));
    return parts.join(' ');
  })();

  const modelPart = model ? 'Model: ' + model : '';
  const providerPart = provider ? 'Prov: ' + provider : '';
  const cwdPart = cwdBase ? 'cwd: ' + cwdBase : '';
  const branchPart = gitBranch ? '\\uE0A0 ' + gitBranch : '';
  const diffPart = gitDiff || '';

  // Background segments (powerline-like blocks)
  const sModel = seg(88, 15, modelPart); // dark red
  const sProvider = seg(160, 15, providerPart); // red
  const sCtx = seg(220, 0, ctxPart + (cachePart ? ' (' + cachePart.trim() + ')' : '')); // yellow
  const sUsage = seg(173, 0, usagePart); // orange-ish
  const sBranch = seg(24, 15, branchPart); // blue
  const sDiff = seg(34, 0, diffPart); // green
  const sCwd = seg(238, 15, cwdPart); // gray
  const sExtra = seg(99, 15, compactPart.trim()); // purple-ish

  return [sModel, sProvider, sCtx, sUsage, sBranch, sDiff, sCwd, sExtra].filter(Boolean).join('');
}

async function main() {
  const factoryConfig = readJsonFile(CONFIG_PATH) || {};

  const cwd = process.cwd();
  const cwdBase = path.basename(cwd) || cwd;
  const workspaceDirs = resolveWorkspaceDirs(cwd);
  const knownIdsByWorkspace = new Map();
  for (const dir of workspaceDirs) {
    const set = new Set();
    for (const c of listSessionCandidates(dir)) set.add(c.id);
    knownIdsByWorkspace.set(dir, set);
  }

  const { resumeFlag, resumeId } = parseResume(ARGS);

  let sessionId = null;
  let workspaceDir = null;
  if (resumeId) {
    sessionId = resumeId;
    workspaceDir = findWorkspaceDirForSessionId(workspaceDirs, sessionId) || workspaceDirs[0] || null;
  } else {
    let abortResolve = false;
    const shouldAbort = () => abortResolve;

    const byProcPromise = resolveSessionFromProcessGroup(shouldAbort, 20);

    let picked = null;
    if (resumeFlag) {
      // For --resume without an explicit id, don't block startup too long on ps/lsof.
      // Prefer process-group resolution when it is fast; otherwise fall back to latest.
      picked = await Promise.race([
        byProcPromise,
        sleep(400).then(() => null),
      ]);
      if (!picked) picked = pickLatestSessionAcross(workspaceDirs);
    } else {
      const freshPromise = waitForNewSessionAcross(workspaceDirs, knownIdsByWorkspace, START_MS, shouldAbort);
      picked = await firstNonNull([byProcPromise, freshPromise]);
      if (!picked) picked = pickLatestSessionAcross(workspaceDirs);
    }

    abortResolve = true;

    sessionId = picked?.id || null;
    workspaceDir = picked?.workspaceDir || workspaceDirs[0] || null;
  }

  if (!sessionId || !workspaceDir) return;
  const sessionIdLower = String(sessionId).toLowerCase();

  const { settingsPath, settings } = resolveSessionSettings(workspaceDir, sessionId);
  const modelId =
    (settings && typeof settings.model === 'string' ? settings.model : null) || resolveGlobalSettingsModel();

  const provider = resolveProvider(modelId, factoryConfig);
  const underlyingModel = resolveUnderlyingModelId(modelId, factoryConfig) || modelId || 'unknown';

  let last = { cacheReadInputTokens: 0, contextCount: 0, outputTokens: 0 };
  let sessionUsage = settings && typeof settings.tokenUsage === 'object' && settings.tokenUsage ? settings.tokenUsage : {};
  let compacting = false;
  let lastRenderAt = 0;
  let lastRenderedLine = '';
  let gitBranch = '';
  let gitDiff = '';

  function renderNow() {
    const usedTokens = (last.cacheReadInputTokens || 0) + (last.contextCount || 0);
    const line = buildLine({
      provider,
      model: underlyingModel,
      cwdBase,
      gitBranch,
      gitDiff,
      usedTokens,
      cacheRead: last.cacheReadInputTokens || 0,
      deltaInput: last.contextCount || 0,
      lastOutputTokens: last.outputTokens || 0,
      sessionUsage,
      compacting,
    });
    if (line !== lastRenderedLine) {
      lastRenderedLine = line;
      emitFrame(line);
    }
  }

  // Initial render.
  renderNow();

  // Resolve git info asynchronously so startup isn't blocked on large repos.
  setTimeout(() => {
    try {
      gitBranch = resolveGitBranch(cwd);
      gitDiff = resolveGitDiffSummary(cwd);
      renderNow();
    } catch {}
  }, 0).unref();

  // Seed prompt-context usage from existing logs (important for resumed sessions).
  // Do this asynchronously to avoid delaying the first statusline frame.
  if (resumeFlag || resumeId) {
    setTimeout(() => {
      try {
        // Backward scan to find the most recent streaming-context entry for this session.
        // The log can be large and shared across multiple sessions.
        const MAX_SCAN_BYTES = 64 * 1024 * 1024; // 64 MiB
        const CHUNK_BYTES = 1024 * 1024; // 1 MiB

        const fd = fs.openSync(LOG_PATH, 'r');
        try {
          const stat = fs.fstatSync(fd);
          const size = Number(stat?.size ?? 0);
          let pos = size;
          let scanned = 0;
          let remainder = '';
          let seeded = false;

          while (pos > 0 && scanned < MAX_SCAN_BYTES && !seeded) {
            const readSize = Math.min(CHUNK_BYTES, pos);
            const start = pos - readSize;
            const buf = Buffer.alloc(readSize);
            fs.readSync(fd, buf, 0, readSize, start);
            pos = start;
            scanned += readSize;

            let text = buf.toString('utf8') + remainder;
            let lines = String(text).split('\\n');
            remainder = lines.shift() || '';
            if (pos === 0 && remainder) {
              lines.unshift(remainder);
              remainder = '';
            }

            for (let i = lines.length - 1; i >= 0; i--) {
              const line = String(lines[i] || '').trimEnd();
              if (!line) continue;
              if (!line.includes('Context:')) continue;
              if (!line.includes('"sessionId":"' + sessionId + '"')) continue;
              if (!line.includes('[Agent] Streaming result')) continue;
              const ctxIndex = line.indexOf('Context: ');
              if (ctxIndex === -1) continue;
              const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
              let ctx;
              try {
                ctx = JSON.parse(jsonStr);
              } catch {
                continue;
              }
              const cacheRead = Number(ctx?.cacheReadInputTokens ?? 0);
              const contextCount = Number(ctx?.contextCount ?? 0);
              const out = Number(ctx?.outputTokens ?? 0);
              if (Number.isFinite(cacheRead)) last.cacheReadInputTokens = cacheRead;
              if (Number.isFinite(contextCount)) last.contextCount = contextCount;
              if (Number.isFinite(out)) last.outputTokens = out;
              seeded = true;
              break;
            }

            if (remainder.length > 8192) remainder = remainder.slice(-8192);
          }
        } finally {
          try {
            fs.closeSync(fd);
          } catch {}
        }

        renderNow();
      } catch {
        // ignore
      }
    }, 0).unref();
  }

  // Watch session settings for autonomy/reasoning changes (cheap polling with mtime).
  let settingsMtimeMs = 0;
  setInterval(() => {
    try {
      const stat = fs.statSync(settingsPath);
      if (stat.mtimeMs === settingsMtimeMs) return;
      settingsMtimeMs = stat.mtimeMs;
      const next = readJsonFile(settingsPath) || {};

      // Keep session token usage in sync (used by /status).
      if (next && typeof next.tokenUsage === 'object' && next.tokenUsage) {
        sessionUsage = next.tokenUsage;
      }

      const now = Date.now();
      if (now - lastRenderAt >= MIN_RENDER_INTERVAL_MS) {
        lastRenderAt = now;
        renderNow();
      }
    } catch {
      // ignore
    }
  }, 750).unref();

  // Follow the Factory log and update based on session-scoped events.
  const tail = spawn('tail', ['-n', '0', '-F', LOG_PATH], {
    stdio: ['ignore', 'pipe', 'ignore'],
  });

  let buffer = '';
  tail.stdout.on('data', (chunk) => {
    buffer += String(chunk);
    while (true) {
      const idx = buffer.indexOf('\\n');
      if (idx === -1) break;
      const line = buffer.slice(0, idx).trimEnd();
      buffer = buffer.slice(idx + 1);

      const lineSessionId = extractSessionIdFromLine(line);
      const isSessionLine =
        lineSessionId && String(lineSessionId).toLowerCase() === sessionIdLower;

      let compactionChanged = false;
      if (line.includes('[Compaction]')) {
        // Accept session-scoped compaction lines; allow end markers to clear even
        // if the line lacks a session id (some builds omit Context on end lines).
        if (isSessionLine || (compacting && !lineSessionId)) {
          const next = nextCompactionState(line, compacting);
          if (next !== compacting) {
            compacting = next;
            compactionChanged = true;
          }
        }
      }

      if (!line.includes('Context:')) {
        if (compactionChanged) {
          lastRenderAt = Date.now();
          renderNow();
        }
        continue;
      }
      if (!isSessionLine) {
        if (compactionChanged) {
          lastRenderAt = Date.now();
          renderNow();
        }
        continue;
      }

      const ctxIndex = line.indexOf('Context: ');
      if (ctxIndex === -1) continue;
      const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
      let ctx;
      try {
        ctx = JSON.parse(jsonStr);
      } catch {
        if (compactionChanged) {
          lastRenderAt = Date.now();
          renderNow();
        }
        continue;
      }

      // Streaming token usage (best source for current context usage).
      if (line.includes('[Agent] Streaming result')) {
        const cacheRead = Number(ctx?.cacheReadInputTokens ?? 0);
        const contextCount = Number(ctx?.contextCount ?? 0);
        const out = Number(ctx?.outputTokens ?? 0);
        if (Number.isFinite(cacheRead)) last.cacheReadInputTokens = cacheRead;
        if (Number.isFinite(contextCount)) last.contextCount = contextCount;
        if (Number.isFinite(out)) last.outputTokens = out;
      }

      const now = Date.now();
      if (compactionChanged || now - lastRenderAt >= MIN_RENDER_INTERVAL_MS) {
        lastRenderAt = now;
        renderNow();
      }
    }
  });

  const stop = () => {
    try { tail.kill('SIGTERM'); } catch {}
    process.exit(0);
  };

  process.on('SIGTERM', stop);
  process.on('SIGINT', stop);
  process.on('SIGHUP', stop);
}

main().catch(() => {});
`;
}

function generateStatuslineWrapperScript(
  execTargetPath: string,
  monitorScriptPath: string,
  sessionsScriptPath?: string,
): string {
  // Bun-only: kept for backward-compat in source, but generates Bun wrapper.
  return generateStatuslineWrapperScriptBun(execTargetPath, monitorScriptPath, sessionsScriptPath);
  /*
  const execTargetJson = JSON.stringify(execTargetPath);
  const monitorScriptJson = JSON.stringify(monitorScriptPath);
  const sessionsScriptJson = sessionsScriptPath ? JSON.stringify(sessionsScriptPath) : "None";

  return `#!/usr/bin/env python3
# Droid with Statusline (PTY proxy)
# Auto-generated by droid-patch --statusline
#
# Design goal (KISS + no flicker):
# - droid draws into a child PTY sized to (terminal_rows - RESERVED_ROWS)
# - this wrapper is the ONLY writer to the real terminal
# - a Node monitor emits statusline frames to a pipe; wrapper renders the latest frame
#   onto the reserved bottom row (a stable "second footer line").

import os
import pty
import re
import select
import signal
import struct
import subprocess
import sys
import termios
import time
import tty
import fcntl

EXEC_TARGET = ${execTargetJson}
STATUSLINE_MONITOR = ${monitorScriptJson}
SESSIONS_SCRIPT = ${sessionsScriptJson}

IS_APPLE_TERMINAL = os.environ.get("TERM_PROGRAM") == "Apple_Terminal"
MIN_RENDER_INTERVAL_MS = 800 if IS_APPLE_TERMINAL else 400
QUIET_MS = 50  # Reduced to prevent statusline disappearing
FORCE_REPAINT_INTERVAL_MS = 2000  # Force repaint every 2 seconds
RESERVED_ROWS = 1

BYPASS_FLAGS = {"--help", "-h", "--version", "-V"}
BYPASS_COMMANDS = {"help", "version", "completion", "completions", "exec"}

def _should_passthrough(argv):
    # Any help/version flags before "--"
    for a in argv:
        if a == "--":
            break
        if a in BYPASS_FLAGS:
            return True

    # Top-level command token
    end_opts = False
    cmd = None
    for a in argv:
        if a == "--":
            end_opts = True
            continue
        if (not end_opts) and a.startswith("-"):
            continue
        cmd = a
        break

    return cmd in BYPASS_COMMANDS

def _exec_passthrough():
    try:
        os.execvp(EXEC_TARGET, [EXEC_TARGET] + sys.argv[1:])
    except Exception as e:
        sys.stderr.write(f"[statusline] passthrough failed: {e}\\n")
        sys.exit(1)

def _is_sessions_command(argv):
    for a in argv:
        if a == "--":
            return False
        if a == "--sessions":
            return True
    return False

def _run_sessions():
    if SESSIONS_SCRIPT and os.path.exists(SESSIONS_SCRIPT):
        os.execvp("node", ["node", SESSIONS_SCRIPT])
    else:
        sys.stderr.write("[statusline] sessions script not found\\n")
        sys.exit(1)

# Handle --sessions command
if _is_sessions_command(sys.argv[1:]):
    _run_sessions()

# Passthrough for non-interactive/meta commands (avoid clearing screen / PTY proxy)
if (not sys.stdin.isatty()) or (not sys.stdout.isatty()) or _should_passthrough(sys.argv[1:]):
    _exec_passthrough()

ANSI_RE = re.compile(r"\\x1b\\[[0-9;]*m")
RESET_SGR = "\\x1b[0m"

def _term_size():
    try:
        sz = os.get_terminal_size(sys.stdout.fileno())
        return int(sz.lines), int(sz.columns)
    except Exception:
        return 24, 80

def _set_winsize(fd: int, rows: int, cols: int) -> None:
    try:
        winsz = struct.pack("HHHH", max(1, rows), max(1, cols), 0, 0)
        fcntl.ioctl(fd, termios.TIOCSWINSZ, winsz)
    except Exception:
        pass

def _visible_width(text: str) -> int:
    # Remove only SGR sequences; good enough for our generated segments.
    stripped = ANSI_RE.sub("", text)
    return len(stripped)

def _clamp_ansi(text: str, cols: int) -> str:
    if cols <= 0:
        return text
    # Avoid writing into the last column. Some terminals keep an implicit wrap-pending state
    # when the last column is filled, and the next printable character can trigger a scroll.
    cols = cols - 1 if cols > 1 else cols
    if cols < 10:
        return text
    visible = 0
    i = 0
    out = []
    while i < len(text):
        ch = text[i]
        if ch == "\\x1b":
            m = text.find("m", i)
            if m != -1:
                out.append(text[i : m + 1])
                i = m + 1
                continue
            out.append(ch)
            i += 1
            continue
        if visible >= cols:
            break
        out.append(ch)
        i += 1
        visible += 1
    if i < len(text) and cols >= 1:
        if visible >= cols:
            if out:
                out[-1] = "…"
            else:
                out.append("…")
        else:
            out.append("…")
        out.append("\\x1b[0m")
    return "".join(out)

def _split_segments(text: str):
    if not text:
        return []
    segments = []
    start = 0
    while True:
        idx = text.find(RESET_SGR, start)
        if idx == -1:
            tail = text[start:]
            if tail:
                segments.append(tail)
            break
        seg = text[start : idx + len(RESET_SGR)]
        if seg:
            segments.append(seg)
        start = idx + len(RESET_SGR)
    return segments

def _wrap_segments(segments, cols: int):
    if not segments:
        return [""]
    if cols <= 0:
        return ["".join(segments)]

    lines = []
    cur = []
    cur_w = 0

    for seg in segments:
        seg_w = _visible_width(seg)
        if seg_w <= 0:
            continue

        if not cur:
            if seg_w > cols:
                seg = _clamp_ansi(seg, cols)
                seg_w = _visible_width(seg)
            cur = [seg]
            cur_w = seg_w
            continue

        if cur_w + seg_w <= cols:
            cur.append(seg)
            cur_w += seg_w
        else:
            lines.append("".join(cur))
            if seg_w > cols:
                seg = _clamp_ansi(seg, cols)
                seg_w = _visible_width(seg)
            cur = [seg]
            cur_w = seg_w

    if cur:
        lines.append("".join(cur))

    return lines if lines else [""]

class StatusRenderer:
    def __init__(self):
        self._raw = ""
        self._segments = []
        self._lines = [""]
        self._active_reserved_rows = RESERVED_ROWS
        self._last_render_ms = 0
        self._last_child_out_ms = 0
        self._force_repaint = False
        self._urgent = False
        self._cursor_visible = True

    def note_child_output(self):
        self._last_child_out_ms = int(time.time() * 1000)

    def set_cursor_visible(self, visible: bool):
        self._cursor_visible = bool(visible)

    def force_repaint(self, urgent: bool = False):
        self._force_repaint = True
        if urgent:
            self._urgent = True

    def set_active_reserved_rows(self, reserved_rows: int):
        try:
            self._active_reserved_rows = max(1, int(reserved_rows or 1))
        except Exception:
            self._active_reserved_rows = 1

    def set_line(self, line: str):
        if line != self._raw:
            self._raw = line
            self._segments = _split_segments(line)
            self._force_repaint = True

    def _write(self, b: bytes) -> None:
        try:
            os.write(sys.stdout.fileno(), b)
        except Exception:
            pass

    def desired_reserved_rows(self, physical_rows: int, cols: int, min_reserved: int):
        try:
            rows = int(physical_rows or 24)
        except Exception:
            rows = 24
        try:
            cols = int(cols or 80)
        except Exception:
            cols = 80

        max_reserved = max(1, rows - 4)
        segments = self._segments if self._segments else ([self._raw] if self._raw else [])
        lines = _wrap_segments(segments, cols) if segments else [""]

        needed = min(len(lines), max_reserved)
        desired = max(int(min_reserved or 1), needed)
        desired = min(desired, max_reserved)

        if len(lines) < desired:
            lines = [""] * (desired - len(lines)) + lines
        if len(lines) > desired:
            lines = lines[-desired:]

        self._lines = lines
        return desired

    def clear_reserved_area(
        self,
        physical_rows: int,
        cols: int,
        reserved_rows: int,
        restore_row: int = 1,
        restore_col: int = 1,
    ):
        try:
            rows = int(physical_rows or 24)
        except Exception:
            rows = 24
        try:
            cols = int(cols or 80)
        except Exception:
            cols = 80
        try:
            reserved = max(1, int(reserved_rows or 1))
        except Exception:
            reserved = 1

        reserved = min(reserved, rows)
        start_row = rows - reserved + 1
        parts = ["\\x1b[?2026h", "\\x1b[?25l", RESET_SGR]
        for i in range(reserved):
            parts.append(f"\\x1b[{start_row + i};1H\\x1b[2K")
        parts.append(f"\\x1b[{restore_row};{restore_col}H")
        parts.append("\\x1b[?25h" if self._cursor_visible else "\\x1b[?25l")
        parts.append("\\x1b[?2026l")
        self._write("".join(parts).encode("utf-8", "ignore"))

    def render(self, physical_rows: int, cols: int, restore_row: int = 1, restore_col: int = 1) -> None:
        now_ms = int(time.time() * 1000)
        if not self._force_repaint:
            return
        if not self._raw:
            self._force_repaint = False
            self._urgent = False
            return
        if (not self._urgent) and (now_ms - self._last_render_ms < MIN_RENDER_INTERVAL_MS):
            return
        # Avoid repainting while child is actively writing (reduces flicker on macOS Terminal).
        if (not self._urgent) and (QUIET_MS > 0 and now_ms - self._last_child_out_ms < QUIET_MS):
            return

        try:
            rows = int(physical_rows or 24)
        except Exception:
            rows = 24
        try:
            cols = int(cols or 80)
        except Exception:
            cols = 80

        if cols <= 0:
            cols = 80

        reserved = max(1, min(self._active_reserved_rows, max(1, rows - 4)))
        start_row = rows - reserved + 1

        lines = self._lines or [""]
        if len(lines) < reserved:
            lines = [""] * (reserved - len(lines)) + lines
        if len(lines) > reserved:
            lines = lines[-reserved:]

        child_rows = rows - reserved

        parts = ["\\x1b[?2026h", "\\x1b[?25l"]
        # Always set scroll region to exclude statusline area
        parts.append(f"\\x1b[1;{child_rows}r")
        for i in range(reserved):
            row = start_row + i
            text = _clamp_ansi(lines[i], cols)
            parts.append(f"\\x1b[{row};1H{RESET_SGR}\\x1b[2K")
            parts.append(f"\\x1b[{row};1H{text}{RESET_SGR}")
        parts.append(f"\\x1b[{restore_row};{restore_col}H")
        parts.append("\\x1b[?25h" if self._cursor_visible else "\\x1b[?25l")
        parts.append("\\x1b[?2026l")

        self._write("".join(parts).encode("utf-8", "ignore"))
        self._last_render_ms = now_ms
        self._force_repaint = False
        self._urgent = False

    def clear(self):
        r, c = _term_size()
        self.clear_reserved_area(r, c, max(self._active_reserved_rows, RESERVED_ROWS))


class OutputRewriter:
    # Rewrite a small subset of ANSI cursor positioning commands to ensure the child UI never
    # draws into the reserved statusline rows.
    #
    # Key idea: many TUIs use "ESC[999;1H" to jump to the terminal bottom. If we forward that
    # unmodified, it targets the *physical* bottom row, overwriting our statusline. We clamp it
    # to "max_row" (physical_rows - reserved_rows) so the child's "bottom" becomes the line
    # just above the statusline.
    def __init__(self):
        self._buf = b""

    def feed(self, chunk: bytes, max_row: int) -> bytes:
        if not chunk:
            return b""

        data = self._buf + chunk
        self._buf = b""
        out = bytearray()
        n = len(data)
        i = 0

        def _is_final_byte(v: int) -> bool:
            return 0x40 <= v <= 0x7E

        while i < n:
            b = data[i]
            if b != 0x1B:  # ESC
                out.append(b)
                i += 1
                continue

            if i + 1 >= n:
                self._buf = data[i:]
                break

            nxt = data[i + 1]
            if nxt != 0x5B:  # not CSI
                out.append(b)
                i += 1
                continue

            # CSI sequence: ESC [ ... <final>
            j = i + 2
            while j < n and not _is_final_byte(data[j]):
                j += 1
            if j >= n:
                self._buf = data[i:]
                break

            final = data[j]
            seq = data[i : j + 1]

            if final in (ord("H"), ord("f")) and max_row > 0:
                params = data[i + 2 : j]
                try:
                    s = params.decode("ascii", "ignore")
                except Exception:
                    s = ""

                # Only handle the simple numeric form (no private/DEC prefixes like "?")
                if not s or s[0] in "0123456789;":
                    parts = s.split(";") if s else []
                    try:
                        row = int(parts[0]) if (len(parts) >= 1 and parts[0]) else 1
                    except Exception:
                        row = 1
                    try:
                        col = int(parts[1]) if (len(parts) >= 2 and parts[1]) else 1
                    except Exception:
                        col = 1

                    if row == 999 or row > max_row:
                        row = max_row
                    if row < 1:
                        row = 1
                    if col < 1:
                        col = 1

                    new_params = f"{row};{col}".encode("ascii", "ignore")
                    seq = b"\\x1b[" + new_params + bytes([final])

            elif final == ord("r") and max_row > 0:
                # DECSTBM - Set scrolling region. If the child resets to the full physical screen
                # (e.g. ESC[r), the reserved statusline row becomes scrollable and our statusline
                # will "float" upward when the UI scrolls. Clamp bottom to max_row (child area).
                params = data[i + 2 : j]
                try:
                    s = params.decode("ascii", "ignore")
                except Exception:
                    s = ""

                # Only handle the simple numeric form (no private/DEC prefixes like "?")
                if not s or s[0] in "0123456789;":
                    parts = s.split(";") if s else []
                    try:
                        top = int(parts[0]) if (len(parts) >= 1 and parts[0]) else 1
                    except Exception:
                        top = 1
                    try:
                        bottom = int(parts[1]) if (len(parts) >= 2 and parts[1]) else max_row
                    except Exception:
                        bottom = max_row

                    if top <= 0:
                        top = 1
                    if bottom <= 0 or bottom == 999 or bottom > max_row:
                        bottom = max_row
                    if top > bottom:
                        top = 1

                    seq = f"\\x1b[{top};{bottom}r".encode("ascii", "ignore")

            out.extend(seq)
            i = j + 1

        return bytes(out)


class CursorTracker:
    # Best-effort cursor tracking so the wrapper can restore the cursor position without using
    # ESC7/ESC8 (which droid/Ink also uses internally).
    def __init__(self):
        self.row = 1
        self.col = 1
        self._saved_row = 1
        self._saved_col = 1
        self._buf = b""
        self._in_osc = False
        self._utf8_cont = 0
        self._wrap_pending = False

    def position(self):
        return self.row, self.col

    def feed(self, chunk: bytes, max_row: int, max_col: int) -> None:
        if not chunk:
            return
        try:
            max_row = max(1, int(max_row or 1))
        except Exception:
            max_row = 1
        try:
            max_col = max(1, int(max_col or 1))
        except Exception:
            max_col = 1

        data = self._buf + chunk
        self._buf = b""
        n = len(data)
        i = 0

        def _clamp():
            if self.row < 1:
                self.row = 1
            elif self.row > max_row:
                self.row = max_row
            if self.col < 1:
                self.col = 1
            elif self.col > max_col:
                self.col = max_col

        def _parse_int(v: str, default: int) -> int:
            try:
                return int(v) if v else default
            except Exception:
                return default

        while i < n:
            b = data[i]

            if self._in_osc:
                # OSC/DCS/etc are terminated by BEL or ST (ESC \\).
                if b == 0x07:
                    self._in_osc = False
                    i += 1
                    continue
                if b == 0x1B:
                    if i + 1 >= n:
                        self._buf = data[i:]
                        break
                    if data[i + 1] == 0x5C:
                        self._in_osc = False
                        i += 2
                        continue
                i += 1
                continue

            if self._utf8_cont > 0:
                if 0x80 <= b <= 0xBF:
                    self._utf8_cont -= 1
                    i += 1
                    continue
                self._utf8_cont = 0

            if b == 0x1B:  # ESC
                self._wrap_pending = False
                if i + 1 >= n:
                    self._buf = data[i:]
                    break
                nxt = data[i + 1]

                if nxt == 0x5B:  # CSI
                    j = i + 2
                    while j < n and not (0x40 <= data[j] <= 0x7E):
                        j += 1
                    if j >= n:
                        self._buf = data[i:]
                        break
                    final = data[j]
                    params = data[i + 2 : j]
                    try:
                        s = params.decode("ascii", "ignore")
                    except Exception:
                        s = ""

                    if s and s[0] not in "0123456789;":
                        i = j + 1
                        continue

                    parts = s.split(";") if s else []
                    p0 = _parse_int(parts[0] if len(parts) >= 1 else "", 1)
                    p1 = _parse_int(parts[1] if len(parts) >= 2 else "", 1)

                    if final in (ord("H"), ord("f")):
                        self.row = p0
                        self.col = p1
                        _clamp()
                    elif final == ord("A"):
                        self.row = max(1, self.row - p0)
                    elif final == ord("B"):
                        self.row = min(max_row, self.row + p0)
                    elif final == ord("C"):
                        self.col = min(max_col, self.col + p0)
                    elif final == ord("D"):
                        self.col = max(1, self.col - p0)
                    elif final == ord("E"):
                        self.row = min(max_row, self.row + p0)
                        self.col = 1
                    elif final == ord("F"):
                        self.row = max(1, self.row - p0)
                        self.col = 1
                    elif final == ord("G"):
                        self.col = p0
                        _clamp()
                    elif final == ord("d"):
                        self.row = p0
                        _clamp()
                    elif final == ord("r"):
                        # DECSTBM moves the cursor to the home position.
                        self.row = 1
                        self.col = 1
                    elif final == ord("s"):
                        self._saved_row = self.row
                        self._saved_col = self.col
                    elif final == ord("u"):
                        self.row = self._saved_row
                        self.col = self._saved_col
                        _clamp()

                    i = j + 1
                    continue

                # OSC, DCS, PM, APC, SOS (terminated by ST or BEL).
                if nxt == 0x5D or nxt in (0x50, 0x5E, 0x5F, 0x58):
                    self._in_osc = True
                    i += 2
                    continue

                # DECSC / DECRC
                if nxt == 0x37:
                    self._saved_row = self.row
                    self._saved_col = self.col
                    i += 2
                    continue
                if nxt == 0x38:
                    self.row = self._saved_row
                    self.col = self._saved_col
                    _clamp()
                    i += 2
                    continue

                # Other single-escape sequences (ignore).
                i += 2
                continue

            if b == 0x0D:  # CR
                self.col = 1
                self._wrap_pending = False
                i += 1
                continue
            if b in (0x0A, 0x0B, 0x0C):  # LF/VT/FF
                self.row = min(max_row, self.row + 1)
                self._wrap_pending = False
                i += 1
                continue
            if b == 0x08:  # BS
                self.col = max(1, self.col - 1)
                self._wrap_pending = False
                i += 1
                continue
            if b == 0x09:  # TAB
                next_stop = ((self.col - 1) // 8 + 1) * 8 + 1
                self.col = min(max_col, next_stop)
                self._wrap_pending = False
                i += 1
                continue

            if b < 0x20 or b == 0x7F:
                i += 1
                continue

            # Printable characters.
            if self._wrap_pending:
                self.row = min(max_row, self.row + 1)
                self.col = 1
                self._wrap_pending = False

            if b >= 0x80:
                if (b & 0xE0) == 0xC0:
                    self._utf8_cont = 1
                elif (b & 0xF0) == 0xE0:
                    self._utf8_cont = 2
                elif (b & 0xF8) == 0xF0:
                    self._utf8_cont = 3
                else:
                    self._utf8_cont = 0

            if self.col < max_col:
                self.col += 1
            else:
                self.col = max_col
                self._wrap_pending = True

            i += 1


def main():
    # Start from a clean viewport. Droid's TUI assumes a fresh screen; without this,
    # it can visually mix with prior shell output (especially when scrollback exists).
    try:
        os.write(sys.stdout.fileno(), b"\\x1b[?2026h\\x1b[0m\\x1b[r\\x1b[2J\\x1b[H\\x1b[?2026l")
    except Exception:
        pass

    renderer = StatusRenderer()
    renderer.set_line("\\x1b[48;5;238m\\x1b[38;5;15m Statusline: starting… \\x1b[0m")
    renderer.force_repaint(True)

    physical_rows, physical_cols = _term_size()
    effective_reserved_rows = renderer.desired_reserved_rows(physical_rows, physical_cols, RESERVED_ROWS)
    renderer.set_active_reserved_rows(effective_reserved_rows)

    child_rows = max(4, physical_rows - effective_reserved_rows)
    child_cols = max(10, physical_cols)

    # Reserve the bottom rows up-front, before the child starts writing.
    try:
        seq = f"\\x1b[?2026h\\x1b[?25l\\x1b[1;{child_rows}r\\x1b[1;1H\\x1b[?25h\\x1b[?2026l"
        os.write(sys.stdout.fileno(), seq.encode("utf-8", "ignore"))
    except Exception:
        pass
    renderer.force_repaint(True)
    renderer.render(physical_rows, physical_cols)

    master_fd, slave_fd = pty.openpty()
    _set_winsize(slave_fd, child_rows, child_cols)

    child = subprocess.Popen(
        [EXEC_TARGET] + sys.argv[1:],
        stdin=slave_fd,
        stdout=slave_fd,
        stderr=slave_fd,
        close_fds=True,
        start_new_session=True,
    )
    os.close(slave_fd)

    rewriter = OutputRewriter()
    cursor = CursorTracker()

    monitor = None
    try:
        monitor_env = os.environ.copy()
        try:
            monitor_env["DROID_STATUSLINE_PGID"] = str(os.getpgid(child.pid))
        except Exception:
            monitor_env["DROID_STATUSLINE_PGID"] = str(child.pid)
        monitor = subprocess.Popen(
            ["node", STATUSLINE_MONITOR] + sys.argv[1:],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            close_fds=True,
            bufsize=0,
            env=monitor_env,
        )
    except Exception:
        monitor = None

    monitor_fd = monitor.stdout.fileno() if (monitor and monitor.stdout) else None

    def forward(sig, _frame):
        try:
            os.killpg(child.pid, sig)
        except Exception:
            pass

    for s in (signal.SIGTERM, signal.SIGINT, signal.SIGHUP):
        try:
            signal.signal(s, forward)
        except Exception:
            pass

    stdin_fd = sys.stdin.fileno()
    stdout_fd = sys.stdout.fileno()
    old_tty = termios.tcgetattr(stdin_fd)
    try:
        tty.setraw(stdin_fd)
        # Ensure stdout is blocking (prevents sporadic EAGAIN/BlockingIOError on some terminals).
        try:
            os.set_blocking(stdout_fd, True)
        except Exception:
            pass
        os.set_blocking(stdin_fd, False)
        os.set_blocking(master_fd, False)
        if monitor_fd is not None:
            os.set_blocking(monitor_fd, False)

        monitor_buf = b""
        detect_buf = b""
        cursor_visible = True
        last_physical_rows = 0
        last_physical_cols = 0
        scroll_region_dirty = True
        last_force_repaint_ms = int(time.time() * 1000)

        while True:
            if child.poll() is not None:
                break

            read_fds = [master_fd, stdin_fd]
            if monitor_fd is not None:
                read_fds.append(monitor_fd)

            try:
                rlist, _, _ = select.select(read_fds, [], [], 0.05)
            except InterruptedError:
                rlist = []

            pty_eof = False
            for fd in rlist:
                if fd == stdin_fd:
                    try:
                        data = os.read(stdin_fd, 4096)
                        if data:
                            os.write(master_fd, data)
                    except BlockingIOError:
                        pass
                    except OSError:
                        pass
                elif fd == master_fd:
                    try:
                        data = os.read(master_fd, 65536)
                    except BlockingIOError:
                        data = b""
                    except OSError:
                        data = b""

                    if data:
                        detect_buf = (detect_buf + data)[-128:]
                        # Detect sequences that may affect scroll region or clear screen
                        needs_scroll_region_reset = (
                            (b"\\x1b[?1049" in detect_buf)  # Alt screen
                            or (b"\\x1b[?1047" in detect_buf)  # Alt screen
                            or (b"\\x1b[?47" in detect_buf)  # Alt screen
                            or (b"\\x1b[J" in detect_buf)  # Clear below
                            or (b"\\x1b[0J" in detect_buf)  # Clear below
                            or (b"\\x1b[1J" in detect_buf)  # Clear above
                            or (b"\\x1b[2J" in detect_buf)  # Clear all
                            or (b"\\x1b[3J" in detect_buf)  # Clear scrollback
                            or (b"\\x1b[r" in detect_buf)  # Reset scroll region (bare ESC[r)
                        )
                        # Also detect scroll region changes with parameters (DECSTBM pattern ESC[n;mr)
                        if b"\\x1b[" in detect_buf and b"r" in detect_buf:
                            if re.search(b"\\x1b\\\\[[0-9]*;?[0-9]*r", detect_buf):
                                needs_scroll_region_reset = True
                        if needs_scroll_region_reset:
                            renderer.force_repaint(True)
                            scroll_region_dirty = True
                        h = detect_buf.rfind(b"\\x1b[?25h")
                        l = detect_buf.rfind(b"\\x1b[?25l")
                        if h != -1 or l != -1:
                            cursor_visible = h > l
                            renderer.set_cursor_visible(cursor_visible)
                        renderer.note_child_output()
                        data = rewriter.feed(data, child_rows)
                        cursor.feed(data, child_rows, child_cols)
                        try:
                            os.write(stdout_fd, data)
                        except BlockingIOError:
                            # If stdout is non-blocking for some reason, retry briefly.
                            try:
                                time.sleep(0.01)
                                os.write(stdout_fd, data)
                            except Exception:
                                pass
                        except OSError:
                            pass
                    else:
                        pty_eof = True
                elif monitor_fd is not None and fd == monitor_fd:
                    try:
                        chunk = os.read(monitor_fd, 65536)
                    except BlockingIOError:
                        chunk = b""
                    except OSError:
                        chunk = b""

                    if chunk:
                        monitor_buf += chunk
                        while True:
                            nl = monitor_buf.find(b"\\n")
                            if nl == -1:
                                break
                            raw = monitor_buf[:nl].rstrip(b"\\r")
                            monitor_buf = monitor_buf[nl + 1 :]
                            if not raw:
                                continue
                            renderer.set_line(raw.decode("utf-8", "replace"))
                    else:
                        monitor_fd = None

            if pty_eof:
                break

            physical_rows, physical_cols = _term_size()
            size_changed = (physical_rows != last_physical_rows) or (physical_cols != last_physical_cols)

            desired = renderer.desired_reserved_rows(physical_rows, physical_cols, RESERVED_ROWS)
            if size_changed or (desired != effective_reserved_rows):
                cr, cc = cursor.position()
                if desired < effective_reserved_rows:
                    renderer.clear_reserved_area(physical_rows, physical_cols, effective_reserved_rows, cr, cc)

                effective_reserved_rows = desired
                renderer.set_active_reserved_rows(effective_reserved_rows)

                child_rows = max(4, physical_rows - effective_reserved_rows)
                child_cols = max(10, physical_cols)
                _set_winsize(master_fd, child_rows, child_cols)
                try:
                    os.killpg(child.pid, signal.SIGWINCH)
                except Exception:
                    pass

                scroll_region_dirty = True
                renderer.force_repaint(urgent=True)  # Use urgent mode to ensure immediate repaint
                last_physical_rows = physical_rows
                last_physical_cols = physical_cols

            cr, cc = cursor.position()
            if cr < 1:
                cr = 1
            if cc < 1:
                cc = 1
            if cr > child_rows:
                cr = child_rows
            if cc > child_cols:
                cc = child_cols

            if scroll_region_dirty:
                # Keep the reserved rows out of the terminal scroll region (esp. after resize).
                try:
                    seq = f"\\x1b[?2026h\\x1b[?25l\\x1b[1;{child_rows}r\\x1b[{cr};{cc}H"
                    seq += "\\x1b[?25h" if cursor_visible else "\\x1b[?25l"
                    seq += "\\x1b[?2026l"
                    os.write(stdout_fd, seq.encode("utf-8", "ignore"))
                except Exception:
                    pass
                scroll_region_dirty = False

            # Periodic force repaint to ensure statusline doesn't disappear
            now_ms = int(time.time() * 1000)
            if now_ms - last_force_repaint_ms >= FORCE_REPAINT_INTERVAL_MS:
                renderer.force_repaint(False)
                last_force_repaint_ms = now_ms

            renderer.render(physical_rows, physical_cols, cr, cc)

    finally:
        try:
            termios.tcsetattr(stdin_fd, termios.TCSADRAIN, old_tty)
        except Exception:
            pass
        try:
            renderer.clear()
        except Exception:
            pass
        try:
            # Restore terminal scroll region and attributes.
            os.write(stdout_fd, b"\\x1b[r\\x1b[0m\\x1b[?25h")
        except Exception:
            pass
        try:
            os.close(master_fd)
        except Exception:
            pass
        if monitor is not None:
            try:
                monitor.terminate()
            except Exception:
                pass

    sys.exit(child.returncode or 0)


if __name__ == "__main__":
    main()
`;
*/
}

function generateStatuslineWrapperScriptBun(
  execTargetPath: string,
  monitorScriptPath: string,
  sessionsScriptPath?: string,
): string {
  const execTargetJson = JSON.stringify(execTargetPath);
  const monitorScriptJson = JSON.stringify(monitorScriptPath);
  const sessionsScriptJson = sessionsScriptPath ? JSON.stringify(sessionsScriptPath) : "null";

  // Notes:
  // - Requires Bun >= 1.3.5 (Bun.Terminal via Bun.spawn({ terminal }))
  // - Keep dependencies zero; this file is written as a standalone executable.
  return `#!/usr/bin/env bun
// Droid with Statusline (Bun PTY proxy)
// Auto-generated by droid-patch --statusline

const EXEC_TARGET = ${execTargetJson};
const STATUSLINE_MONITOR = ${monitorScriptJson};
const SESSIONS_SCRIPT = ${sessionsScriptJson};

const IS_APPLE_TERMINAL = process.env.TERM_PROGRAM === "Apple_Terminal";
const MIN_RENDER_INTERVAL_MS = IS_APPLE_TERMINAL ? 800 : 400;
const QUIET_MS = 50;
const FORCE_REPAINT_INTERVAL_MS = 2000;
const RESERVED_ROWS = 1;

const BYPASS_FLAGS = new Set(["--help", "-h", "--version", "-V"]);
const BYPASS_COMMANDS = new Set(["help", "version", "completion", "completions", "exec"]);

function shouldPassthrough(argv) {
  for (const a of argv) {
    if (a === "--") break;
    if (BYPASS_FLAGS.has(a)) return true;
  }
  let endOpts = false;
  let cmd = null;
  for (const a of argv) {
    if (a === "--") {
      endOpts = true;
      continue;
    }
    if (!endOpts && a.startsWith("-")) continue;
    cmd = a;
    break;
  }
  return cmd && BYPASS_COMMANDS.has(cmd);
}

function isSessionsCommand(argv) {
  for (const a of argv) {
    if (a === "--") return false;
    if (a === "--sessions") return true;
  }
  return false;
}

async function execPassthrough(argv) {
  const proc = Bun.spawn([EXEC_TARGET, ...argv], {
    stdin: "inherit",
    stdout: "inherit",
    stderr: "inherit",
  });
  const code = await proc.exited;
  process.exit(code ?? 0);
}

async function runSessions() {
  if (SESSIONS_SCRIPT) {
    const proc = Bun.spawn(["node", String(SESSIONS_SCRIPT)], {
      stdin: "inherit",
      stdout: "inherit",
      stderr: "inherit",
    });
    const code = await proc.exited;
    process.exit(code ?? 0);
  }
  process.stderr.write("[statusline] sessions script not found\\n");
  process.exit(1);
}

function writeStdout(s) {
  try {
    process.stdout.write(s);
  } catch {
    // ignore
  }
}

function termSize() {
  const rows = Number(process.stdout.rows || 24);
  const cols = Number(process.stdout.columns || 80);
  return { rows: Number.isFinite(rows) ? rows : 24, cols: Number.isFinite(cols) ? cols : 80 };
}

const ANSI_RE = /\\x1b\\[[0-9;]*m/g;
const RESET_SGR = "\\x1b[0m";

function visibleWidth(text) {
  return String(text || "").replace(ANSI_RE, "").length;
}

function clampAnsi(text, cols) {
  if (!cols || cols <= 0) return String(text || "");
  cols = cols > 1 ? cols - 1 : cols; // avoid last-column wrap
  if (cols < 10) return String(text || "");
  const s = String(text || "");
  let visible = 0;
  let i = 0;
  const out = [];
  while (i < s.length) {
    const ch = s[i];
    if (ch === "\\x1b") {
      const m = s.indexOf("m", i);
      if (m !== -1) {
        out.push(s.slice(i, m + 1));
        i = m + 1;
        continue;
      }
      out.push(ch);
      i += 1;
      continue;
    }
    if (visible >= cols) break;
    out.push(ch);
    i += 1;
    visible += 1;
  }
  if (i < s.length && cols >= 1) {
    if (visible >= cols) {
      if (out.length) out[out.length - 1] = "…";
      else out.push("…");
    } else {
      out.push("…");
    }
    out.push(RESET_SGR);
  }
  return out.join("");
}

function splitSegments(text) {
  if (!text) return [];
  const s = String(text);
  const segments = [];
  let start = 0;
  while (true) {
    const idx = s.indexOf(RESET_SGR, start);
    if (idx === -1) {
      const tail = s.slice(start);
      if (tail) segments.push(tail);
      break;
    }
    const seg = s.slice(start, idx + RESET_SGR.length);
    if (seg) segments.push(seg);
    start = idx + RESET_SGR.length;
  }
  return segments;
}

function wrapSegments(segments, cols) {
  if (!segments || segments.length === 0) return [""];
  if (!cols || cols <= 0) return [segments.join("")];

  const lines = [];
  let cur = [];
  let curW = 0;

  for (let seg of segments) {
    let segW = visibleWidth(seg);
    if (segW <= 0) continue;

    if (cur.length === 0) {
      if (segW > cols) {
        seg = clampAnsi(seg, cols);
        segW = visibleWidth(seg);
      }
      cur = [seg];
      curW = segW;
      continue;
    }

    if (curW + segW <= cols) {
      cur.push(seg);
      curW += segW;
    } else {
      lines.push(cur.join(""));
      if (segW > cols) {
        seg = clampAnsi(seg, cols);
        segW = visibleWidth(seg);
      }
      cur = [seg];
      curW = segW;
    }
  }

  if (cur.length) lines.push(cur.join(""));
  return lines.length ? lines : [""];
}

class StatusRenderer {
  constructor() {
    this.raw = "";
    this.segments = [];
    this.lines = [""];
    this.activeReservedRows = RESERVED_ROWS;
    this.force = false;
    this.urgent = false;
    this.lastRenderMs = 0;
    this.lastChildOutMs = 0;
    this.cursorVisible = true;
  }
  noteChildOutput() {
    this.lastChildOutMs = Date.now();
  }
  setCursorVisible(v) {
    this.cursorVisible = !!v;
  }
  forceRepaint(urgent = false) {
    this.force = true;
    if (urgent) this.urgent = true;
  }
  setActiveReservedRows(n) {
    const v = Number(n || 1);
    this.activeReservedRows = Number.isFinite(v) ? Math.max(1, Math.trunc(v)) : 1;
  }
  setLine(line) {
    const next = String(line || "");
    if (next !== this.raw) {
      this.raw = next;
      this.segments = splitSegments(next);
      this.force = true;
    }
  }
  desiredReservedRows(physicalRows, cols, minReserved) {
    let rows = Number(physicalRows || 24);
    rows = Number.isFinite(rows) ? rows : 24;
    cols = Number(cols || 80);
    cols = Number.isFinite(cols) ? cols : 80;

    const maxReserved = Math.max(1, rows - 4);
    const segs = this.segments.length ? this.segments : (this.raw ? [this.raw] : []);
    let lines = segs.length ? wrapSegments(segs, cols) : [""];

    const needed = Math.min(lines.length, maxReserved);
    let desired = Math.max(Number(minReserved || 1), needed);
    desired = Math.min(desired, maxReserved);

    if (lines.length < desired) lines = new Array(desired - lines.length).fill("").concat(lines);
    if (lines.length > desired) lines = lines.slice(-desired);

    this.lines = lines;
    return desired;
  }
  clearReservedArea(physicalRows, cols, reservedRows, restoreRow = 1, restoreCol = 1) {
    let rows = Number(physicalRows || 24);
    rows = Number.isFinite(rows) ? rows : 24;
    cols = Number(cols || 80);
    cols = Number.isFinite(cols) ? cols : 80;
    let reserved = Number(reservedRows || 1);
    reserved = Number.isFinite(reserved) ? Math.max(1, Math.trunc(reserved)) : 1;

    reserved = Math.min(reserved, rows);
    const startRow = rows - reserved + 1;
    const parts = ["\\x1b[?2026h", "\\x1b[?25l", RESET_SGR];
    for (let i = 0; i < reserved; i++) parts.push("\\x1b[" + (startRow + i) + ";1H\\x1b[2K");
    parts.push("\\x1b[" + restoreRow + ";" + restoreCol + "H");
    parts.push(this.cursorVisible ? "\\x1b[?25h" : "\\x1b[?25l");
    parts.push("\\x1b[?2026l");
    writeStdout(parts.join(""));
  }
  render(physicalRows, cols, restoreRow = 1, restoreCol = 1) {
    if (!this.force) return;
    if (!this.raw) {
      this.force = false;
      this.urgent = false;
      return;
    }
    const now = Date.now();
    if (!this.urgent && now - this.lastRenderMs < MIN_RENDER_INTERVAL_MS) return;
    if (!this.urgent && QUIET_MS > 0 && now - this.lastChildOutMs < QUIET_MS) return;

    let rows = Number(physicalRows || 24);
    rows = Number.isFinite(rows) ? rows : 24;
    cols = Number(cols || 80);
    cols = Number.isFinite(cols) ? cols : 80;
    if (cols <= 0) cols = 80;

    const reserved = Math.max(1, Math.min(this.activeReservedRows, Math.max(1, rows - 4)));
    const startRow = rows - reserved + 1;
    const childRows = rows - reserved;

    let lines = this.lines.length ? this.lines.slice() : [""];
    if (lines.length < reserved) lines = new Array(reserved - lines.length).fill("").concat(lines);
    if (lines.length > reserved) lines = lines.slice(-reserved);

    const parts = ["\\x1b[?2026h", "\\x1b[?25l"];
    parts.push("\\x1b[1;" + childRows + "r");
    for (let i = 0; i < reserved; i++) {
      const row = startRow + i;
      const text = clampAnsi(lines[i], cols);
      parts.push("\\x1b[" + row + ";1H" + RESET_SGR + "\\x1b[2K");
      parts.push("\\x1b[" + row + ";1H" + text + RESET_SGR);
    }
    parts.push("\\x1b[" + restoreRow + ";" + restoreCol + "H");
    parts.push(this.cursorVisible ? "\\x1b[?25h" : "\\x1b[?25l");
    parts.push("\\x1b[?2026l");
    writeStdout(parts.join(""));

    this.lastRenderMs = now;
    this.force = false;
    this.urgent = false;
  }
  clear() {
    const { rows, cols } = termSize();
    this.clearReservedArea(rows, cols, Math.max(this.activeReservedRows, RESERVED_ROWS));
  }
}

class OutputRewriter {
  constructor() {
    this.buf = new Uint8Array(0);
  }
  feed(chunk, maxRow) {
    if (!chunk || chunk.length === 0) return chunk;
    const merged = new Uint8Array(this.buf.length + chunk.length);
    merged.set(this.buf, 0);
    merged.set(chunk, this.buf.length);
    this.buf = new Uint8Array(0);

    const out = [];
    let i = 0;

    const isFinal = (v) => v >= 0x40 && v <= 0x7e;

    while (i < merged.length) {
      const b = merged[i];
      if (b !== 0x1b) {
        out.push(b);
        i += 1;
        continue;
      }
      if (i + 1 >= merged.length) {
        this.buf = merged.slice(i);
        break;
      }
      const nxt = merged[i + 1];
      if (nxt !== 0x5b) {
        out.push(b);
        i += 1;
        continue;
      }

      let j = i + 2;
      while (j < merged.length && !isFinal(merged[j])) j += 1;
      if (j >= merged.length) {
        this.buf = merged.slice(i);
        break;
      }
      const final = merged[j];
      let seq = merged.slice(i, j + 1);

      if ((final === 0x48 || final === 0x66) && maxRow > 0) {
        const params = merged.slice(i + 2, j);
        const s = new TextDecoder().decode(params);
        if (!s || /^[0-9;]/.test(s)) {
          const parts = s ? s.split(";") : [];
          const row = Number(parts[0] || 1);
          const col = Number(parts[1] || 1);
          let r = Number.isFinite(row) ? row : 1;
          let c = Number.isFinite(col) ? col : 1;
          if (r === 999 || r > maxRow) r = maxRow;
          if (r < 1) r = 1;
          if (c < 1) c = 1;
          const newParams = new TextEncoder().encode(String(r) + ";" + String(c));
          const ns = new Uint8Array(2 + newParams.length + 1);
          ns[0] = 0x1b;
          ns[1] = 0x5b;
          ns.set(newParams, 2);
          ns[ns.length - 1] = final;
          seq = ns;
        }
      } else if (final === 0x72 && maxRow > 0) {
        const params = merged.slice(i + 2, j);
        const s = new TextDecoder().decode(params);
        if (!s || /^[0-9;]/.test(s)) {
          const parts = s ? s.split(";") : [];
          const top = Number(parts[0] || 1);
          const bottom = Number(parts[1] || maxRow);
          let t = Number.isFinite(top) ? top : 1;
          let btm = Number.isFinite(bottom) ? bottom : maxRow;
          if (t <= 0) t = 1;
          if (btm <= 0 || btm === 999 || btm > maxRow) btm = maxRow;
          if (t > btm) t = 1;
          const str = "\\x1b[" + String(t) + ";" + String(btm) + "r";
          seq = new TextEncoder().encode(str);
        }
      }

      for (const bb of seq) out.push(bb);
      i = j + 1;
    }

    return new Uint8Array(out);
  }
}

class CursorTracker {
  constructor() {
    this.row = 1;
    this.col = 1;
    this.savedRow = 1;
    this.savedCol = 1;
    this.buf = new Uint8Array(0);
    this.inOsc = false;
    this.utf8Cont = 0;
    this.wrapPending = false;
  }
  position() {
    return { row: this.row, col: this.col };
  }
  feed(chunk, maxRow, maxCol) {
    if (!chunk || chunk.length === 0) return;
    maxRow = Math.max(1, Number(maxRow || 1));
    maxCol = Math.max(1, Number(maxCol || 1));

    const merged = new Uint8Array(this.buf.length + chunk.length);
    merged.set(this.buf, 0);
    merged.set(chunk, this.buf.length);
    this.buf = new Uint8Array(0);

    const clamp = () => {
      if (this.row < 1) this.row = 1;
      else if (this.row > maxRow) this.row = maxRow;
      if (this.col < 1) this.col = 1;
      else if (this.col > maxCol) this.col = maxCol;
    };

    const parseIntDefault = (v, d) => {
      const n = Number(v);
      return Number.isFinite(n) && n > 0 ? Math.trunc(n) : d;
    };

    let i = 0;
    const isFinal = (v) => v >= 0x40 && v <= 0x7e;

    while (i < merged.length) {
      const b = merged[i];

      if (this.inOsc) {
        if (b === 0x07) {
          this.inOsc = false;
          i += 1;
          continue;
        }
        if (b === 0x1b) {
          if (i + 1 >= merged.length) {
            this.buf = merged.slice(i);
            break;
          }
          if (merged[i + 1] === 0x5c) {
            this.inOsc = false;
            i += 2;
            continue;
          }
        }
        i += 1;
        continue;
      }

      if (this.utf8Cont > 0) {
        if (b >= 0x80 && b <= 0xbf) {
          this.utf8Cont -= 1;
          i += 1;
          continue;
        }
        this.utf8Cont = 0;
      }

      if (b === 0x1b) {
        this.wrapPending = false;
        if (i + 1 >= merged.length) {
          this.buf = merged.slice(i);
          break;
        }
        const nxt = merged[i + 1];

        if (nxt === 0x5b) {
          let j = i + 2;
          while (j < merged.length && !isFinal(merged[j])) j += 1;
          if (j >= merged.length) {
            this.buf = merged.slice(i);
            break;
          }
          const final = merged[j];
          const params = merged.slice(i + 2, j);
          const s = new TextDecoder().decode(params);
          if (s && !/^[0-9;]/.test(s)) {
            i = j + 1;
            continue;
          }
          const parts = s ? s.split(";") : [];
          const p0 = parseIntDefault(parts[0] || "", 1);
          const p1 = parseIntDefault(parts[1] || "", 1);

          if (final === 0x48 || final === 0x66) {
            this.row = p0;
            this.col = p1;
            clamp();
          } else if (final === 0x41) {
            this.row = Math.max(1, this.row - p0);
          } else if (final === 0x42) {
            this.row = Math.min(maxRow, this.row + p0);
          } else if (final === 0x43) {
            this.col = Math.min(maxCol, this.col + p0);
          } else if (final === 0x44) {
            this.col = Math.max(1, this.col - p0);
          } else if (final === 0x45) {
            this.row = Math.min(maxRow, this.row + p0);
            this.col = 1;
          } else if (final === 0x46) {
            this.row = Math.max(1, this.row - p0);
            this.col = 1;
          } else if (final === 0x47) {
            this.col = p0;
            clamp();
          } else if (final === 0x64) {
            this.row = p0;
            clamp();
          } else if (final === 0x72) {
            this.row = 1;
            this.col = 1;
          } else if (final === 0x73) {
            this.savedRow = this.row;
            this.savedCol = this.col;
          } else if (final === 0x75) {
            this.row = this.savedRow;
            this.col = this.savedCol;
            clamp();
          }

          i = j + 1;
          continue;
        }

        if (nxt === 0x5d || nxt === 0x50 || nxt === 0x5e || nxt === 0x5f || nxt === 0x58) {
          this.inOsc = true;
          i += 2;
          continue;
        }

        if (nxt === 0x37) {
          this.savedRow = this.row;
          this.savedCol = this.col;
          i += 2;
          continue;
        }
        if (nxt === 0x38) {
          this.row = this.savedRow;
          this.col = this.savedCol;
          clamp();
          i += 2;
          continue;
        }

        i += 2;
        continue;
      }

      if (b === 0x0d) {
        this.col = 1;
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b === 0x0a || b === 0x0b || b === 0x0c) {
        this.row = Math.min(maxRow, this.row + 1);
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b === 0x08) {
        this.col = Math.max(1, this.col - 1);
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b === 0x09) {
        const nextStop = Math.floor((this.col - 1) / 8 + 1) * 8 + 1;
        this.col = Math.min(maxCol, nextStop);
        this.wrapPending = false;
        i += 1;
        continue;
      }
      if (b < 0x20 || b === 0x7f) {
        i += 1;
        continue;
      }

      if (this.wrapPending) {
        this.row = Math.min(maxRow, this.row + 1);
        this.col = 1;
        this.wrapPending = false;
      }

      if (b >= 0x80) {
        if ((b & 0xe0) === 0xc0) this.utf8Cont = 1;
        else if ((b & 0xf0) === 0xe0) this.utf8Cont = 2;
        else if ((b & 0xf8) === 0xf0) this.utf8Cont = 3;
        else this.utf8Cont = 0;
      }

      if (this.col < maxCol) this.col += 1;
      else {
        this.col = maxCol;
        this.wrapPending = true;
      }
      i += 1;
    }
  }
}

async function main() {
  const argv = process.argv.slice(2);

  if (isSessionsCommand(argv)) await runSessions();

  if (!process.stdin.isTTY || !process.stdout.isTTY || shouldPassthrough(argv)) {
    await execPassthrough(argv);
    return;
  }

  // Clean viewport.
  writeStdout("\\x1b[?2026h\\x1b[0m\\x1b[r\\x1b[2J\\x1b[H\\x1b[?2026l");

  const renderer = new StatusRenderer();
  renderer.setLine("\\x1b[48;5;238m\\x1b[38;5;15m Statusline: starting… \\x1b[0m");
  renderer.forceRepaint(true);

  let { rows: physicalRows, cols: physicalCols } = termSize();
  let effectiveReservedRows = renderer.desiredReservedRows(physicalRows, physicalCols, RESERVED_ROWS);
  renderer.setActiveReservedRows(effectiveReservedRows);
  let childRows = Math.max(4, physicalRows - effectiveReservedRows);
  let childCols = Math.max(10, physicalCols);

  // Reserve the bottom rows early, before the child starts writing.
  writeStdout(
    "\\x1b[?2026h\\x1b[?25l\\x1b[1;" + childRows + "r\\x1b[1;1H\\x1b[?25h\\x1b[?2026l",
  );
  renderer.forceRepaint(true);
  renderer.render(physicalRows, physicalCols, 1, 1);

  // Spawn child with terminal support.
  let child;
  try {
    child = Bun.spawn([EXEC_TARGET, ...argv], {
      cwd: process.cwd(),
      env: process.env,
      detached: true,
      terminal: {
        cols: childCols,
        rows: childRows,
        data(_terminal, data) {
          onChildData(data);
        },
      },
      onExit(_proc, exitCode, signal, _error) {
        onChildExit(exitCode, signal);
      },
    });
  } catch (e) {
    process.stderr.write("[statusline] failed to spawn child: " + String(e?.message || e) + "\\n");
    process.exit(1);
  }

  const terminal = child.terminal;

  // Best-effort PGID resolution (matches Python wrapper behavior).
  // This improves session resolution (ps/lsof scanning) and signal forwarding.
  let pgid = child.pid;
  try {
    const res = Bun.spawnSync(["ps", "-o", "pgid=", "-p", String(child.pid)], {
      stdin: "ignore",
      stdout: "pipe",
      stderr: "ignore",
    });
    if (res && res.exitCode === 0 && res.stdout) {
      const text = new TextDecoder().decode(res.stdout).trim();
      const n = Number(text);
      if (Number.isFinite(n) && n > 0) pgid = Math.trunc(n);
    }
  } catch {}

  // Spawn monitor (Node).
  const monitorEnv = { ...process.env, DROID_STATUSLINE_PGID: String(pgid) };
  const monitor = Bun.spawn(["node", STATUSLINE_MONITOR, ...argv], {
    stdin: "ignore",
    stdout: "pipe",
    stderr: "ignore",
    env: monitorEnv,
  });

  let shouldStop = false;
  const rewriter = new OutputRewriter();
  const cursor = new CursorTracker();

  let detectBuf = new Uint8Array(0);
  let detectStr = "";
  let cursorVisible = true;
  let scrollRegionDirty = true;
  let lastForceRepaintMs = Date.now();
  let lastPhysicalRows = 0;
  let lastPhysicalCols = 0;

  function appendDetect(chunk) {
    const max = 128;
    const merged = new Uint8Array(Math.min(max, detectBuf.length + chunk.length));
    const takePrev = Math.max(0, merged.length - chunk.length);
    if (takePrev > 0) merged.set(detectBuf.slice(Math.max(0, detectBuf.length - takePrev)), 0);
    merged.set(chunk.slice(Math.max(0, chunk.length - (merged.length - takePrev))), takePrev);
    detectBuf = merged;
    try {
      detectStr = Buffer.from(detectBuf).toString("latin1");
    } catch {
      detectStr = "";
    }
  }

  function includesBytes(needle) {
    return detectStr.includes(needle);
  }

  function lastIndexOfBytes(needle) {
    return detectStr.lastIndexOf(needle);
  }

  function includesScrollRegionCSI() {
    // Equivalent to Python: re.search(b"\\x1b\\\\[[0-9]*;?[0-9]*r", detect_buf)
    try {
      return /\\x1b\\[[0-9]*;?[0-9]*r/.test(detectStr);
    } catch {
      return false;
    }
  }

  function updateCursorVisibility() {
    const show = includesBytes("\\x1b[?25h");
    const hide = includesBytes("\\x1b[?25l");
    if (show || hide) {
      // best-effort: if both present, whichever appears later "wins"
      const h = lastIndexOfBytes("\\x1b[?25h");
      const l = lastIndexOfBytes("\\x1b[?25l");
      cursorVisible = h > l;
      renderer.setCursorVisible(cursorVisible);
    }
  }

  function needsScrollRegionReset() {
    return (
      includesBytes("\\x1b[?1049") ||
      includesBytes("\\x1b[?1047") ||
      includesBytes("\\x1b[?47") ||
      includesBytes("\\x1b[J") ||
      includesBytes("\\x1b[0J") ||
      includesBytes("\\x1b[1J") ||
      includesBytes("\\x1b[2J") ||
      includesBytes("\\x1b[3J") ||
      includesBytes("\\x1b[r") ||
      includesScrollRegionCSI()
    );
  }

  function onChildData(data) {
    if (shouldStop) return;
    const chunk = data instanceof Uint8Array ? data : new Uint8Array(data);
    appendDetect(chunk);
    if (needsScrollRegionReset()) scrollRegionDirty = true;
    updateCursorVisibility();

    renderer.noteChildOutput();
    const rewritten = rewriter.feed(chunk, childRows);
    cursor.feed(rewritten, childRows, childCols);
    writeStdout(Buffer.from(rewritten));
  }

  function onChildExit(exitCode, signal) {
    if (shouldStop) return;
    shouldStop = true;
    const code = exitCode ?? (signal != null ? 128 + signal : 0);
    cleanup().finally(() => process.exit(code));
  }

  async function readMonitor() {
    if (!monitor.stdout) return;
    const reader = monitor.stdout.getReader();
    let buf = "";
    while (!shouldStop) {
      const { value, done } = await reader.read();
      if (done || !value) break;
      buf += new TextDecoder().decode(value);
      while (true) {
        const idx = buf.indexOf("\\n");
        if (idx === -1) break;
        const line = buf.slice(0, idx).replace(/\\r$/, "");
        buf = buf.slice(idx + 1);
        if (!line) continue;
        renderer.setLine(line);
        renderer.forceRepaint(false);
      }
    }
  }
  readMonitor().catch(() => {});

  function repaintStatusline(forceUrgent = false) {
    const { row, col } = cursor.position();
    let r = Math.max(1, Math.min(childRows, row));
    let c = Math.max(1, Math.min(childCols, col));

    if (scrollRegionDirty) {
      const seq =
        "\\x1b[?2026h\\x1b[?25l\\x1b[1;" +
        childRows +
        "r\\x1b[" +
        r +
        ";" +
        c +
        "H" +
        (cursorVisible ? "\\x1b[?25h" : "\\x1b[?25l") +
        "\\x1b[?2026l";
      writeStdout(seq);
      scrollRegionDirty = false;
    }

    renderer.forceRepaint(forceUrgent);
    renderer.render(physicalRows, physicalCols, r, c);
  }

  function handleSizeChange(nextRows, nextCols, forceUrgent = false) {
    physicalRows = nextRows;
    physicalCols = nextCols;

    const desired = renderer.desiredReservedRows(physicalRows, physicalCols, RESERVED_ROWS);
    const { row, col } = cursor.position();
    if (desired < effectiveReservedRows) {
      renderer.clearReservedArea(physicalRows, physicalCols, effectiveReservedRows, row, col);
    }
    effectiveReservedRows = desired;
    renderer.setActiveReservedRows(effectiveReservedRows);

    childRows = Math.max(4, physicalRows - effectiveReservedRows);
    childCols = Math.max(10, physicalCols);
    try {
      terminal.resize(childCols, childRows);
    } catch {}
    try {
      process.kill(-child.pid, "SIGWINCH");
    } catch {
      try { process.kill(child.pid, "SIGWINCH"); } catch {}
    }

    scrollRegionDirty = true;
    renderer.forceRepaint(true);
    repaintStatusline(forceUrgent);
  }

  process.on("SIGWINCH", () => {
    const next = termSize();
    handleSizeChange(next.rows, next.cols, true);
  });

  // Forward signals to child's process group when possible.
  const forward = (sig) => {
    try {
      process.kill(-pgid, sig);
    } catch {
      try {
        process.kill(child.pid, sig);
      } catch {}
    }
  };
  for (const s of ["SIGTERM", "SIGINT", "SIGHUP"]) {
    try {
      process.on(s, () => forward(s));
    } catch {}
  }

  // Raw stdin -> PTY.
  try {
    process.stdin.setRawMode(true);
  } catch {}
  process.stdin.resume();
  process.stdin.on("data", (buf) => {
    try {
      if (typeof buf === "string") terminal.write(buf);
      else {
        // Prefer bytes when supported; fall back to UTF-8 decoding.
        try {
          // Bun.Terminal.write may accept Uint8Array in newer versions.
          terminal.write(buf);
        } catch {
          terminal.write(new TextDecoder().decode(buf));
        }
      }
    } catch {}
  });

  const tick = setInterval(() => {
    if (shouldStop) return;
    const next = termSize();
    const sizeChanged = next.rows !== lastPhysicalRows || next.cols !== lastPhysicalCols;
    const desired = renderer.desiredReservedRows(next.rows, next.cols, RESERVED_ROWS);
    if (sizeChanged || desired !== effectiveReservedRows) {
      handleSizeChange(next.rows, next.cols, true);
      lastPhysicalRows = next.rows;
      lastPhysicalCols = next.cols;
      lastForceRepaintMs = Date.now();
      return;
    }
    const now = Date.now();
    if (now - lastForceRepaintMs >= FORCE_REPAINT_INTERVAL_MS) {
      repaintStatusline(false);
      lastForceRepaintMs = now;
    } else {
      const { row, col } = cursor.position();
      renderer.render(physicalRows, physicalCols, row, col);
    }
  }, 50);

  async function cleanup() {
    clearInterval(tick);
    try {
      process.stdin.setRawMode(false);
    } catch {}
    try {
      const { row, col } = cursor.position();
      renderer.clearReservedArea(physicalRows, physicalCols, effectiveReservedRows, row, col);
    } catch {}
    try {
      writeStdout("\\x1b[r\\x1b[0m\\x1b[?25h");
    } catch {}
    try {
      monitor.kill();
    } catch {}
    try {
      terminal.close();
    } catch {}
  }

  // Keep process alive until child exits.
  await child.exited;
  await cleanup();
}

main().catch(() => process.exit(1));
`;
}

export async function createStatuslineFiles(
  outputDir: string,
  execTargetPath: string,
  aliasName: string,
  sessionsScriptPath?: string,
): Promise<{ wrapperScript: string; monitorScript: string }> {
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const monitorScriptPath = join(outputDir, `${aliasName}-statusline.js`);
  const wrapperScriptPath = join(outputDir, aliasName);

  await writeFile(monitorScriptPath, generateStatuslineMonitorScript());
  await chmod(monitorScriptPath, 0o755);

  const wrapper = generateStatuslineWrapperScript(
    execTargetPath,
    monitorScriptPath,
    sessionsScriptPath,
  );

  await writeFile(wrapperScriptPath, wrapper);
  await chmod(wrapperScriptPath, 0o755);

  return { wrapperScript: wrapperScriptPath, monitorScript: monitorScriptPath };
}
