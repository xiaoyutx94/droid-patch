import { chmod, mkdir, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join } from "node:path";

function generateStatuslineMonitorScript(): string {
  // Keep this script dependency-free (Node built-ins only). It runs from the wrapper via `node`.
  return `#!/usr/bin/env node
/* Auto-generated by droid-patch --statusline */

const fs = require('fs');
const os = require('os');
const path = require('path');
const { spawn, spawnSync } = require('child_process');

// This monitor does NOT draw directly to the terminal. It emits newline-delimited
// statusline frames to stdout. A wrapper (PTY proxy) is responsible for rendering
// the latest frame on a reserved bottom row to avoid flicker.

const FACTORY_HOME = path.join(os.homedir(), '.factory');

const SESSIONS_ROOT = path.join(FACTORY_HOME, 'sessions');
const LOG_PATH = path.join(FACTORY_HOME, 'logs', 'droid-log-single.log');
const CONFIG_PATH = path.join(FACTORY_HOME, 'config.json');
const GLOBAL_SETTINGS_PATH = path.join(FACTORY_HOME, 'settings.json');

const IS_APPLE_TERMINAL = process.env.TERM_PROGRAM === 'Apple_Terminal';
const MIN_RENDER_INTERVAL_MS = IS_APPLE_TERMINAL ? 1000 : 500;

const START_MS = Date.now();
const ARGS = process.argv.slice(2);
const PGID = Number(process.env.DROID_STATUSLINE_PGID || '');

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function isPositiveInt(n) {
  return Number.isFinite(n) && n > 0;
}

function listPidsInProcessGroup(pgid) {
  if (!isPositiveInt(pgid)) return [];
  try {
    const res = spawnSync('ps', ['-ax', '-o', 'pid=,pgid='], {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (!res || res.status !== 0) return [];
    const out = String(res.stdout || '');
    const pids = [];
    for (const line of out.split('\\n')) {
      const parts = line.trim().split(/\\s+/);
      if (parts.length < 2) continue;
      const pid = Number(parts[0]);
      const g = Number(parts[1]);
      if (Number.isFinite(pid) && g === pgid) pids.push(pid);
    }
    return pids;
  } catch {
    return [];
  }
}

function resolveOpenSessionFromPids(pids) {
  if (!Array.isArray(pids) || pids.length === 0) return null;
  // lsof prints file names as lines prefixed with "n" when using -Fn
  try {
    const res = spawnSync('lsof', ['-p', pids.join(','), '-Fn'], {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 1200,
    });
    if (!res || res.status !== 0) return null;
    const out = String(res.stdout || '');
    for (const line of out.split('\\n')) {
      if (!line || line[0] !== 'n') continue;
      const name = line.slice(1);
      if (!name.startsWith(SESSIONS_ROOT + path.sep)) continue;
      const m = name.match(/([0-9a-f-]{36})\\.(jsonl|settings\\.json)$/i);
      if (!m) continue;
      const id = m[1];
      const workspaceDir = path.dirname(name);
      if (path.dirname(workspaceDir) !== SESSIONS_ROOT) continue;
      return { workspaceDir, id };
    }
  } catch {
    return null;
  }
  return null;
}

async function resolveSessionFromProcessGroup() {
  if (!isPositiveInt(PGID)) return null;
  // Wait a little for droid to create/open the session files.
  for (let i = 0; i < 80; i++) {
    const pids = listPidsInProcessGroup(PGID);
    const found = resolveOpenSessionFromPids(pids);
    if (found) return found;
    await sleep(100);
  }
  return null;
}

function safeReadFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch {
    return null;
  }
}

function safeJsonParse(text) {
  if (!text) return null;
  try {
    // Factory settings/config files can contain comments. Strip them safely without
    // breaking URLs like "http://..." which contain "//" inside strings.
    const stripComments = (input) => {
      let out = '';
      let inString = false;
      let escape = false;
      for (let i = 0; i < input.length; i++) {
        const ch = input[i];
        const next = input[i + 1];

        if (inString) {
          out += ch;
          if (escape) {
            escape = false;
            continue;
          }
          if (ch === '\\\\') {
            escape = true;
            continue;
          }
          if (ch === '"') {
            inString = false;
          }
          continue;
        }

        if (ch === '"') {
          inString = true;
          out += ch;
          continue;
        }

        // Line comment
        if (ch === '/' && next === '/') {
          while (i < input.length && input[i] !== '\\n') i++;
          out += '\\n';
          continue;
        }

        // Block comment
        if (ch === '/' && next === '*') {
          i += 2;
          while (i < input.length && !(input[i] === '*' && input[i + 1] === '/')) i++;
          i += 1;
          continue;
        }

        out += ch;
      }
      return out;
    };

    return JSON.parse(stripComments(text));
  } catch {
    return null;
  }
}

function readJsonFile(filePath) {
  return safeJsonParse(safeReadFile(filePath));
}

function isUuid(text) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(text);
}

function parseResume(args) {
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '-r' || a === '--resume') {
      const next = args[i + 1];
      if (next && isUuid(next)) return { resumeFlag: true, resumeId: next };
      return { resumeFlag: true, resumeId: null };
    }
    if (a.startsWith('--resume=')) {
      const value = a.slice('--resume='.length);
      return { resumeFlag: true, resumeId: isUuid(value) ? value : null };
    }
  }
  return { resumeFlag: false, resumeId: null };
}

function sanitizeWorkspaceDirName(cwd) {
  return String(cwd)
    .replace(/[:]/g, '')
    .replace(/[\\\\/]/g, '-')
    .replace(/\\s+/g, '-');
}

function listSessionCandidates(workspaceDir) {
  let files = [];
  try {
    files = fs.readdirSync(workspaceDir);
  } catch {
    return [];
  }
  const candidates = [];
  for (const file of files) {
    const m = file.match(/^([0-9a-f-]{36})\\.(jsonl|settings\\.json)$/i);
    if (!m) continue;
    const id = m[1];
    const fullPath = path.join(workspaceDir, file);
    try {
      const stat = fs.statSync(fullPath);
      candidates.push({ id, fullPath, mtimeMs: stat.mtimeMs });
    } catch {
      // ignore
    }
  }
  return candidates;
}

function findWorkspaceDirForSessionId(workspaceDirs, sessionId) {
  for (const dir of workspaceDirs) {
    try {
      const settingsPath = path.join(dir, sessionId + '.settings.json');
      if (fs.existsSync(settingsPath)) return dir;
    } catch {
      // ignore
    }
  }
  return null;
}

function pickLatestSessionAcross(workspaceDirs) {
  let best = null;
  for (const dir of workspaceDirs) {
    const candidates = listSessionCandidates(dir);
    for (const c of candidates) {
      if (!best || c.mtimeMs > best.mtimeMs) {
        best = { workspaceDir: dir, id: c.id, mtimeMs: c.mtimeMs };
      }
    }
  }
  return best ? { workspaceDir: best.workspaceDir, id: best.id } : null;
}

async function waitForNewSessionAcross(workspaceDirs, knownIdsByWorkspace, startMs) {
  for (let i = 0; i < 80; i++) {
    let best = null;
    for (const dir of workspaceDirs) {
      const known = knownIdsByWorkspace.get(dir) || new Set();
      const candidates = listSessionCandidates(dir);
      for (const c of candidates) {
        if (!(c.mtimeMs >= startMs - 50 || !known.has(c.id))) continue;
        if (!best || c.mtimeMs > best.mtimeMs) {
          best = { workspaceDir: dir, id: c.id, mtimeMs: c.mtimeMs };
        }
      }
    }
    if (best?.id) return { workspaceDir: best.workspaceDir, id: best.id };
    await sleep(100);
  }
  return null;
}

function safeRealpath(p) {
  try {
    return fs.realpathSync(p);
  } catch {
    return null;
  }
}

function resolveWorkspaceDirs(cwd) {
  const logical = cwd;
  const real = safeRealpath(cwd);
  const dirs = [];
  for (const value of [logical, real]) {
    if (!value || typeof value !== 'string') continue;
    dirs.push(path.join(SESSIONS_ROOT, sanitizeWorkspaceDirName(value)));
  }
  return Array.from(new Set(dirs));
}

function resolveSessionSettings(workspaceDir, sessionId) {
  const settingsPath = path.join(workspaceDir, sessionId + '.settings.json');
  const settings = readJsonFile(settingsPath) || {};
  return { settingsPath, settings };
}

function resolveGlobalSettingsModel() {
  const global = readJsonFile(GLOBAL_SETTINGS_PATH);
  return global && typeof global.model === 'string' ? global.model : null;
}

function resolveCustomModelIndex(modelId) {
  if (typeof modelId !== 'string') return null;
  if (!modelId.startsWith('custom:')) return null;
  const m = modelId.match(/-(\\d+)$/);
  if (!m) return null;
  const idx = Number(m[1]);
  return Number.isFinite(idx) ? idx : null;
}

function resolveUnderlyingModelId(modelId, factoryConfig) {
  const idx = resolveCustomModelIndex(modelId);
  if (idx == null) return modelId;
  const entry = factoryConfig?.custom_models?.[idx];
  if (entry && typeof entry.model === 'string') return entry.model;
  return modelId;
}

function resolveProvider(modelId, factoryConfig) {
  const idx = resolveCustomModelIndex(modelId);
  if (idx != null) {
    const entry = factoryConfig?.custom_models?.[idx];
    if (entry && typeof entry.provider === 'string') return entry.provider;
  }
  if (typeof modelId === 'string' && modelId.startsWith('claude-')) return 'anthropic';
  return '';
}

function formatInt(n) {
  if (!Number.isFinite(n)) return '0';
  return Math.round(n).toString();
}

function formatTokens(n) {
  if (!Number.isFinite(n)) return '0';
  const sign = n < 0 ? '-' : '';
  const abs = Math.abs(n);
  if (abs >= 1_000_000) {
    const v = abs / 1_000_000;
    const s = v >= 10 ? v.toFixed(0) : v.toFixed(1);
    return sign + s.replace(/\\.0$/, '') + 'M';
  }
  if (abs >= 10_000) {
    const v = abs / 1_000;
    const s = v >= 100 ? v.toFixed(0) : v.toFixed(1);
    return sign + s.replace(/\\.0$/, '') + 'k';
  }
  return sign + Math.round(abs).toString();
}

function emitFrame(line) {
  try {
    process.stdout.write(String(line || '') + '\\n');
  } catch {
    // ignore
  }
}

function seg(bg, fg, text) {
  if (!text) return '';
  return '\\x1b[48;5;' + bg + 'm' + '\\x1b[38;5;' + fg + 'm' + ' ' + text + ' ' + '\\x1b[0m';
}

function resolveGitBranch(cwd) {
  try {
    const res = spawnSync('git', ['rev-parse', '--abbrev-ref', 'HEAD'], {
      cwd,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (res && res.status === 0) {
      const branch = String(res.stdout || '').trim();
      if (branch && branch !== 'HEAD') return branch;
    }
  } catch {}
  try {
    const headPath = path.join(cwd, '.git', 'HEAD');
    const head = safeReadFile(headPath);
    if (head && head.startsWith('ref: ')) {
      const ref = head.slice('ref: '.length).trim();
      const m = ref.match(/refs\\/heads\\/(.+)$/);
      if (m) return m[1];
    }
  } catch {}
  return '';
}

function resolveGitDiffSummary(cwd) {
  try {
    const res = spawnSync('git', ['diff', '--shortstat'], {
      cwd,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
      timeout: 800,
    });
    if (!res || res.status !== 0) return '';
    const text = String(res.stdout || '').trim();
    if (!text) return '';
    const ins = (text.match(/(\\d+)\\sinsertions?\\(\\+\\)/) || [])[1];
    const del = (text.match(/(\\d+)\\sdeletions?\\(-\\)/) || [])[1];
    const i = ins ? Number(ins) : 0;
    const d = del ? Number(del) : 0;
    if (!Number.isFinite(i) && !Number.isFinite(d)) return '';
    if (i === 0 && d === 0) return '';
    return '(+' + formatInt(i) + ',-' + formatInt(d) + ')';
  } catch {
    return '';
  }
}

function buildLine(params) {
  const {
    provider,
    model,
    cwdBase,
    gitBranch,
    gitDiff,
    usedTokens,
    cacheRead,
    deltaInput,
    lastOutputTokens,
    sessionUsage,
    compacting,
  } = params;

  let ctxPart = 'Ctx: ' + formatTokens(usedTokens);

  const cachePart =
    cacheRead > 0 || deltaInput > 0
      ? ' c' + formatTokens(cacheRead) + '+n' + formatTokens(deltaInput)
      : '';

  const compactPart = compacting ? ' COMPACT' : '';

  const usagePart = (() => {
    const u = sessionUsage || {};
    const input = Number(u.inputTokens ?? 0);
    const output = Number(u.outputTokens ?? 0);
    const cacheCreation = Number(u.cacheCreationTokens ?? 0);
    const cacheReadTotal = Number(u.cacheReadTokens ?? 0);
    const thinking = Number(u.thinkingTokens ?? 0);
    if (!(input || output || cacheCreation || cacheReadTotal || thinking)) return '';
    const parts = [];
    if (input) parts.push('In:' + formatTokens(input));
    if (output) parts.push('Out:' + formatTokens(output));
    if (cacheCreation) parts.push('Cre:' + formatTokens(cacheCreation));
    if (cacheReadTotal) parts.push('Read:' + formatTokens(cacheReadTotal));
    if (thinking) parts.push('Think:' + formatTokens(thinking));
    if (lastOutputTokens > 0) parts.push('LastOut:' + formatTokens(lastOutputTokens));
    return parts.join(' ');
  })();

  const modelPart = model ? 'Model: ' + model : '';
  const providerPart = provider ? 'Prov: ' + provider : '';
  const cwdPart = cwdBase ? 'cwd: ' + cwdBase : '';
  const branchPart = gitBranch ? '\\uE0A0 ' + gitBranch : '';
  const diffPart = gitDiff || '';

  // Background segments (powerline-like blocks)
  const sModel = seg(88, 15, modelPart); // dark red
  const sProvider = seg(160, 15, providerPart); // red
  const sCtx = seg(220, 0, ctxPart + (cachePart ? ' (' + cachePart.trim() + ')' : '')); // yellow
  const sUsage = seg(173, 0, usagePart); // orange-ish
  const sBranch = seg(24, 15, branchPart); // blue
  const sDiff = seg(34, 0, diffPart); // green
  const sCwd = seg(238, 15, cwdPart); // gray
  const sExtra = seg(99, 15, compactPart.trim()); // purple-ish

  return [sModel, sProvider, sCtx, sUsage, sBranch, sDiff, sCwd, sExtra].filter(Boolean).join('');
}

async function main() {
  const factoryConfig = readJsonFile(CONFIG_PATH) || {};

  const cwd = process.cwd();
  const cwdBase = path.basename(cwd) || cwd;
  const workspaceDirs = resolveWorkspaceDirs(cwd);
  const knownIdsByWorkspace = new Map();
  for (const dir of workspaceDirs) {
    const set = new Set();
    for (const c of listSessionCandidates(dir)) set.add(c.id);
    knownIdsByWorkspace.set(dir, set);
  }

  const { resumeFlag, resumeId } = parseResume(ARGS);

  let sessionId = null;
  let workspaceDir = null;
  if (resumeId) {
    sessionId = resumeId;
    workspaceDir = findWorkspaceDirForSessionId(workspaceDirs, sessionId) || workspaceDirs[0] || null;
  } else {
    const byProc = await resolveSessionFromProcessGroup();
    if (byProc?.id) {
      sessionId = byProc.id;
      workspaceDir = byProc.workspaceDir;
    } else if (resumeFlag) {
      const latest = pickLatestSessionAcross(workspaceDirs);
      sessionId = latest?.id || null;
      workspaceDir = latest?.workspaceDir || workspaceDirs[0] || null;
    } else {
      const fresh = await waitForNewSessionAcross(workspaceDirs, knownIdsByWorkspace, START_MS);
      if (fresh) {
        sessionId = fresh.id;
        workspaceDir = fresh.workspaceDir;
      } else {
        const latest = pickLatestSessionAcross(workspaceDirs);
        sessionId = latest?.id || null;
        workspaceDir = latest?.workspaceDir || workspaceDirs[0] || null;
      }
    }
  }

  if (!sessionId || !workspaceDir) return;

  const { settingsPath, settings } = resolveSessionSettings(workspaceDir, sessionId);
  const modelId =
    (settings && typeof settings.model === 'string' ? settings.model : null) || resolveGlobalSettingsModel();

  const provider = resolveProvider(modelId, factoryConfig);
  const underlyingModel = resolveUnderlyingModelId(modelId, factoryConfig) || modelId || 'unknown';

  let last = { cacheReadInputTokens: 0, contextCount: 0, outputTokens: 0 };
  let sessionUsage = settings && typeof settings.tokenUsage === 'object' && settings.tokenUsage ? settings.tokenUsage : {};
  let compacting = false;
  let lastRenderAt = 0;
  let lastRenderedLine = '';
  const gitBranch = resolveGitBranch(cwd);
  const gitDiff = resolveGitDiffSummary(cwd);

  function renderNow() {
    const usedTokens = (last.cacheReadInputTokens || 0) + (last.contextCount || 0);
    const line = buildLine({
      provider,
      model: underlyingModel,
      cwdBase,
      gitBranch,
      gitDiff,
      usedTokens,
      cacheRead: last.cacheReadInputTokens || 0,
      deltaInput: last.contextCount || 0,
      lastOutputTokens: last.outputTokens || 0,
      sessionUsage,
      compacting,
    });
    if (line !== lastRenderedLine) {
      lastRenderedLine = line;
      emitFrame(line);
    }
  }

  // Seed prompt-context usage from existing logs (important for resumed sessions and early calls).
  // This avoids showing "Ctx: 0" until the next streaming event arrives.
  try {
    // Backward scan to find the most recent streaming-context entry for this session.
    // The log can be large and shared across multiple sessions, so a small tail slice
    // may miss older resumed sessions.
    const MAX_SCAN_BYTES = 64 * 1024 * 1024; // 64 MiB
    const CHUNK_BYTES = 1024 * 1024; // 1 MiB

    const fd = fs.openSync(LOG_PATH, 'r');
    try {
      const stat = fs.fstatSync(fd);
      const size = Number(stat?.size ?? 0);
      let pos = size;
      let scanned = 0;
      let remainder = '';
      let seeded = false;

      while (pos > 0 && scanned < MAX_SCAN_BYTES && !seeded) {
        const readSize = Math.min(CHUNK_BYTES, pos);
        const start = pos - readSize;
        const buf = Buffer.alloc(readSize);
        fs.readSync(fd, buf, 0, readSize, start);
        pos = start;
        scanned += readSize;

        let text = buf.toString('utf8') + remainder;
        let lines = String(text).split('\\n');
        remainder = lines.shift() || '';
        if (pos === 0 && remainder) {
          lines.unshift(remainder);
          remainder = '';
        }

        for (let i = lines.length - 1; i >= 0; i--) {
          const line = String(lines[i] || '').trimEnd();
          if (!line) continue;
          if (!line.includes('Context:')) continue;
          if (!line.includes('"sessionId":"' + sessionId + '"')) continue;
          if (!line.includes('[Agent] Streaming result')) continue;
          const ctxIndex = line.indexOf('Context: ');
          if (ctxIndex === -1) continue;
          const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
          let ctx;
          try {
            ctx = JSON.parse(jsonStr);
          } catch {
            continue;
          }
          const cacheRead = Number(ctx?.cacheReadInputTokens ?? 0);
          const contextCount = Number(ctx?.contextCount ?? 0);
          const out = Number(ctx?.outputTokens ?? 0);
          if (Number.isFinite(cacheRead)) last.cacheReadInputTokens = cacheRead;
          if (Number.isFinite(contextCount)) last.contextCount = contextCount;
          if (Number.isFinite(out)) last.outputTokens = out;
          seeded = true;
          break;
        }

        if (remainder.length > 8192) remainder = remainder.slice(-8192);
      }
    } finally {
      try {
        fs.closeSync(fd);
      } catch {}
    }
  } catch {
    // ignore
  }

  // Initial render.
  renderNow();

  // Watch session settings for autonomy/reasoning changes (cheap polling with mtime).
  let settingsMtimeMs = 0;
  setInterval(() => {
    try {
      const stat = fs.statSync(settingsPath);
      if (stat.mtimeMs === settingsMtimeMs) return;
      settingsMtimeMs = stat.mtimeMs;
      const next = readJsonFile(settingsPath) || {};

      // Keep session token usage in sync (used by /status).
      if (next && typeof next.tokenUsage === 'object' && next.tokenUsage) {
        sessionUsage = next.tokenUsage;
      }

      const now = Date.now();
      if (now - lastRenderAt >= MIN_RENDER_INTERVAL_MS) {
        lastRenderAt = now;
        renderNow();
      }
    } catch {
      // ignore
    }
  }, 750).unref();

  // Follow the Factory log and update based on session-scoped events.
  const tail = spawn('tail', ['-n', '0', '-F', LOG_PATH], {
    stdio: ['ignore', 'pipe', 'ignore'],
  });

  let buffer = '';
  tail.stdout.on('data', (chunk) => {
    buffer += String(chunk);
    while (true) {
      const idx = buffer.indexOf('\\n');
      if (idx === -1) break;
      const line = buffer.slice(0, idx).trimEnd();
      buffer = buffer.slice(idx + 1);

      if (!line.includes('Context:')) continue;
      if (!line.includes('"sessionId":"' + sessionId + '"')) continue;

      const ctxIndex = line.indexOf('Context: ');
      if (ctxIndex === -1) continue;
      const jsonStr = line.slice(ctxIndex + 'Context: '.length).trim();
      let ctx;
      try {
        ctx = JSON.parse(jsonStr);
      } catch {
        continue;
      }

      // Streaming token usage (best source for current context usage).
      if (line.includes('[Agent] Streaming result')) {
        const cacheRead = Number(ctx?.cacheReadInputTokens ?? 0);
        const contextCount = Number(ctx?.contextCount ?? 0);
        const out = Number(ctx?.outputTokens ?? 0);
        if (Number.isFinite(cacheRead)) last.cacheReadInputTokens = cacheRead;
        if (Number.isFinite(contextCount)) last.contextCount = contextCount;
        if (Number.isFinite(out)) last.outputTokens = out;
      }

      // Compaction state hint.
      if (line.includes('[Compaction] Start')) compacting = true;
      if (line.includes('[Compaction] End')) compacting = false;

      const now = Date.now();
      if (now - lastRenderAt >= MIN_RENDER_INTERVAL_MS) {
        lastRenderAt = now;
        renderNow();
      }
    }
  });

  const stop = () => {
    try { tail.kill('SIGTERM'); } catch {}
    process.exit(0);
  };

  process.on('SIGTERM', stop);
  process.on('SIGINT', stop);
  process.on('SIGHUP', stop);
}

main().catch(() => {});
`;
}

function generateStatuslineWrapperScript(
  execTargetPath: string,
  monitorScriptPath: string,
): string {
  const execTargetJson = JSON.stringify(execTargetPath);
  const monitorScriptJson = JSON.stringify(monitorScriptPath);

  return `#!/usr/bin/env python3
# Droid with Statusline (PTY proxy)
# Auto-generated by droid-patch --statusline
#
# Design goal (KISS + no flicker):
# - droid draws into a child PTY sized to (terminal_rows - RESERVED_ROWS)
# - this wrapper is the ONLY writer to the real terminal
# - a Node monitor emits statusline frames to a pipe; wrapper renders the latest frame
#   onto the reserved bottom row (a stable "second footer line").

import os
import pty
import re
import select
import signal
import struct
import subprocess
import sys
import termios
import time
import tty
import fcntl

EXEC_TARGET = ${execTargetJson}
STATUSLINE_MONITOR = ${monitorScriptJson}

IS_APPLE_TERMINAL = os.environ.get("TERM_PROGRAM") == "Apple_Terminal"
MIN_RENDER_INTERVAL_MS = 1000 if IS_APPLE_TERMINAL else 500
QUIET_MS = 120
RESERVED_ROWS = 1

ANSI_RE = re.compile(r"\\x1b\\[[0-9;]*m")
RESET_SGR = "\\x1b[0m"

def _term_size():
    try:
        sz = os.get_terminal_size(sys.stdout.fileno())
        return int(sz.lines), int(sz.columns)
    except Exception:
        return 24, 80

def _set_winsize(fd: int, rows: int, cols: int) -> None:
    try:
        winsz = struct.pack("HHHH", max(1, rows), max(1, cols), 0, 0)
        fcntl.ioctl(fd, termios.TIOCSWINSZ, winsz)
    except Exception:
        pass

def _visible_width(text: str) -> int:
    # Remove only SGR sequences; good enough for our generated segments.
    stripped = ANSI_RE.sub("", text)
    return len(stripped)

def _clamp_ansi(text: str, cols: int) -> str:
    if cols <= 0:
        return text
    # Avoid writing into the last column. Some terminals keep an implicit wrap-pending state
    # when the last column is filled, and the next printable character can trigger a scroll.
    cols = cols - 1 if cols > 1 else cols
    if cols < 10:
        return text
    visible = 0
    i = 0
    out = []
    while i < len(text):
        ch = text[i]
        if ch == "\\x1b":
            m = text.find("m", i)
            if m != -1:
                out.append(text[i : m + 1])
                i = m + 1
                continue
            out.append(ch)
            i += 1
            continue
        if visible >= cols:
            break
        out.append(ch)
        i += 1
        visible += 1
    if i < len(text) and cols >= 1:
        if visible >= cols:
            if out:
                out[-1] = "…"
            else:
                out.append("…")
        else:
            out.append("…")
        out.append("\\x1b[0m")
    return "".join(out)

def _split_segments(text: str):
    if not text:
        return []
    segments = []
    start = 0
    while True:
        idx = text.find(RESET_SGR, start)
        if idx == -1:
            tail = text[start:]
            if tail:
                segments.append(tail)
            break
        seg = text[start : idx + len(RESET_SGR)]
        if seg:
            segments.append(seg)
        start = idx + len(RESET_SGR)
    return segments

def _wrap_segments(segments, cols: int):
    if not segments:
        return [""]
    if cols <= 0:
        return ["".join(segments)]

    lines = []
    cur = []
    cur_w = 0

    for seg in segments:
        seg_w = _visible_width(seg)
        if seg_w <= 0:
            continue

        if not cur:
            if seg_w > cols:
                seg = _clamp_ansi(seg, cols)
                seg_w = _visible_width(seg)
            cur = [seg]
            cur_w = seg_w
            continue

        if cur_w + seg_w <= cols:
            cur.append(seg)
            cur_w += seg_w
        else:
            lines.append("".join(cur))
            if seg_w > cols:
                seg = _clamp_ansi(seg, cols)
                seg_w = _visible_width(seg)
            cur = [seg]
            cur_w = seg_w

    if cur:
        lines.append("".join(cur))

    return lines if lines else [""]

class StatusRenderer:
    def __init__(self):
        self._raw = ""
        self._segments = []
        self._lines = [""]
        self._active_reserved_rows = RESERVED_ROWS
        self._last_render_ms = 0
        self._last_child_out_ms = 0
        self._force_repaint = False
        self._urgent = False
        self._cursor_visible = True

    def note_child_output(self):
        self._last_child_out_ms = int(time.time() * 1000)

    def set_cursor_visible(self, visible: bool):
        self._cursor_visible = bool(visible)

    def force_repaint(self, urgent: bool = False):
        self._force_repaint = True
        if urgent:
            self._urgent = True

    def set_active_reserved_rows(self, reserved_rows: int):
        try:
            self._active_reserved_rows = max(1, int(reserved_rows or 1))
        except Exception:
            self._active_reserved_rows = 1

    def set_line(self, line: str):
        if line != self._raw:
            self._raw = line
            self._segments = _split_segments(line)
            self._force_repaint = True

    def _write(self, b: bytes) -> None:
        try:
            os.write(sys.stdout.fileno(), b)
        except Exception:
            pass

    def desired_reserved_rows(self, physical_rows: int, cols: int, min_reserved: int):
        try:
            rows = int(physical_rows or 24)
        except Exception:
            rows = 24
        try:
            cols = int(cols or 80)
        except Exception:
            cols = 80

        max_reserved = max(1, rows - 4)
        segments = self._segments if self._segments else ([self._raw] if self._raw else [])
        lines = _wrap_segments(segments, cols) if segments else [""]

        needed = min(len(lines), max_reserved)
        desired = max(int(min_reserved or 1), needed)
        desired = min(desired, max_reserved)

        if len(lines) < desired:
            lines = [""] * (desired - len(lines)) + lines
        if len(lines) > desired:
            lines = lines[-desired:]

        self._lines = lines
        return desired

    def clear_reserved_area(
        self,
        physical_rows: int,
        cols: int,
        reserved_rows: int,
        restore_row: int = 1,
        restore_col: int = 1,
    ):
        try:
            rows = int(physical_rows or 24)
        except Exception:
            rows = 24
        try:
            cols = int(cols or 80)
        except Exception:
            cols = 80
        try:
            reserved = max(1, int(reserved_rows or 1))
        except Exception:
            reserved = 1

        reserved = min(reserved, rows)
        start_row = rows - reserved + 1
        parts = ["\\x1b[?2026h", "\\x1b[?25l", RESET_SGR]
        for i in range(reserved):
            parts.append(f"\\x1b[{start_row + i};1H\\x1b[2K")
        parts.append(f"\\x1b[{restore_row};{restore_col}H")
        parts.append("\\x1b[?25h" if self._cursor_visible else "\\x1b[?25l")
        parts.append("\\x1b[?2026l")
        self._write("".join(parts).encode("utf-8", "ignore"))

    def render(self, physical_rows: int, cols: int, restore_row: int = 1, restore_col: int = 1) -> None:
        now_ms = int(time.time() * 1000)
        if not self._force_repaint:
            return
        if not self._raw:
            self._force_repaint = False
            self._urgent = False
            return
        if (not self._urgent) and (now_ms - self._last_render_ms < MIN_RENDER_INTERVAL_MS):
            return
        # Avoid repainting while child is actively writing (reduces flicker on macOS Terminal).
        if (not self._urgent) and (QUIET_MS > 0 and now_ms - self._last_child_out_ms < QUIET_MS):
            return

        try:
            rows = int(physical_rows or 24)
        except Exception:
            rows = 24
        try:
            cols = int(cols or 80)
        except Exception:
            cols = 80

        if cols <= 0:
            cols = 80

        reserved = max(1, min(self._active_reserved_rows, max(1, rows - 4)))
        start_row = rows - reserved + 1

        lines = self._lines or [""]
        if len(lines) < reserved:
            lines = [""] * (reserved - len(lines)) + lines
        if len(lines) > reserved:
            lines = lines[-reserved:]

        parts = ["\\x1b[?2026h", "\\x1b[?25l"]
        for i in range(reserved):
            row = start_row + i
            text = _clamp_ansi(lines[i], cols)
            parts.append(f"\\x1b[{row};1H{RESET_SGR}\\x1b[2K")
            parts.append(f"\\x1b[{row};1H{text}{RESET_SGR}")
        parts.append(f"\\x1b[{restore_row};{restore_col}H")
        parts.append("\\x1b[?25h" if self._cursor_visible else "\\x1b[?25l")
        parts.append("\\x1b[?2026l")

        self._write("".join(parts).encode("utf-8", "ignore"))
        self._last_render_ms = now_ms
        self._force_repaint = False
        self._urgent = False

    def clear(self):
        r, c = _term_size()
        self.clear_reserved_area(r, c, max(self._active_reserved_rows, RESERVED_ROWS))


class OutputRewriter:
    # Rewrite a small subset of ANSI cursor positioning commands to ensure the child UI never
    # draws into the reserved statusline rows.
    #
    # Key idea: many TUIs use "ESC[999;1H" to jump to the terminal bottom. If we forward that
    # unmodified, it targets the *physical* bottom row, overwriting our statusline. We clamp it
    # to "max_row" (physical_rows - reserved_rows) so the child's "bottom" becomes the line
    # just above the statusline.
    def __init__(self):
        self._buf = b""

    def feed(self, chunk: bytes, max_row: int) -> bytes:
        if not chunk:
            return b""

        data = self._buf + chunk
        self._buf = b""
        out = bytearray()
        n = len(data)
        i = 0

        def _is_final_byte(v: int) -> bool:
            return 0x40 <= v <= 0x7E

        while i < n:
            b = data[i]
            if b != 0x1B:  # ESC
                out.append(b)
                i += 1
                continue

            if i + 1 >= n:
                self._buf = data[i:]
                break

            nxt = data[i + 1]
            if nxt != 0x5B:  # not CSI
                out.append(b)
                i += 1
                continue

            # CSI sequence: ESC [ ... <final>
            j = i + 2
            while j < n and not _is_final_byte(data[j]):
                j += 1
            if j >= n:
                self._buf = data[i:]
                break

            final = data[j]
            seq = data[i : j + 1]

            if final in (ord("H"), ord("f")) and max_row > 0:
                params = data[i + 2 : j]
                try:
                    s = params.decode("ascii", "ignore")
                except Exception:
                    s = ""

                # Only handle the simple numeric form (no private/DEC prefixes like "?")
                if not s or s[0] in "0123456789;":
                    parts = s.split(";") if s else []
                    try:
                        row = int(parts[0]) if (len(parts) >= 1 and parts[0]) else 1
                    except Exception:
                        row = 1
                    try:
                        col = int(parts[1]) if (len(parts) >= 2 and parts[1]) else 1
                    except Exception:
                        col = 1

                    if row == 999 or row > max_row:
                        row = max_row
                    if row < 1:
                        row = 1
                    if col < 1:
                        col = 1

                    new_params = f"{row};{col}".encode("ascii", "ignore")
                    seq = b"\\x1b[" + new_params + bytes([final])

            elif final == ord("r") and max_row > 0:
                # DECSTBM - Set scrolling region. If the child resets to the full physical screen
                # (e.g. ESC[r), the reserved statusline row becomes scrollable and our statusline
                # will "float" upward when the UI scrolls. Clamp bottom to max_row (child area).
                params = data[i + 2 : j]
                try:
                    s = params.decode("ascii", "ignore")
                except Exception:
                    s = ""

                # Only handle the simple numeric form (no private/DEC prefixes like "?")
                if not s or s[0] in "0123456789;":
                    parts = s.split(";") if s else []
                    try:
                        top = int(parts[0]) if (len(parts) >= 1 and parts[0]) else 1
                    except Exception:
                        top = 1
                    try:
                        bottom = int(parts[1]) if (len(parts) >= 2 and parts[1]) else max_row
                    except Exception:
                        bottom = max_row

                    if top <= 0:
                        top = 1
                    if bottom <= 0 or bottom == 999 or bottom > max_row:
                        bottom = max_row
                    if top > bottom:
                        top = 1

                    seq = f"\\x1b[{top};{bottom}r".encode("ascii", "ignore")

            out.extend(seq)
            i = j + 1

        return bytes(out)


class CursorTracker:
    # Best-effort cursor tracking so the wrapper can restore the cursor position without using
    # ESC7/ESC8 (which droid/Ink also uses internally).
    def __init__(self):
        self.row = 1
        self.col = 1
        self._saved_row = 1
        self._saved_col = 1
        self._buf = b""
        self._in_osc = False
        self._utf8_cont = 0
        self._wrap_pending = False

    def position(self):
        return self.row, self.col

    def feed(self, chunk: bytes, max_row: int, max_col: int) -> None:
        if not chunk:
            return
        try:
            max_row = max(1, int(max_row or 1))
        except Exception:
            max_row = 1
        try:
            max_col = max(1, int(max_col or 1))
        except Exception:
            max_col = 1

        data = self._buf + chunk
        self._buf = b""
        n = len(data)
        i = 0

        def _clamp():
            if self.row < 1:
                self.row = 1
            elif self.row > max_row:
                self.row = max_row
            if self.col < 1:
                self.col = 1
            elif self.col > max_col:
                self.col = max_col

        def _parse_int(v: str, default: int) -> int:
            try:
                return int(v) if v else default
            except Exception:
                return default

        while i < n:
            b = data[i]

            if self._in_osc:
                # OSC/DCS/etc are terminated by BEL or ST (ESC \\).
                if b == 0x07:
                    self._in_osc = False
                    i += 1
                    continue
                if b == 0x1B:
                    if i + 1 >= n:
                        self._buf = data[i:]
                        break
                    if data[i + 1] == 0x5C:
                        self._in_osc = False
                        i += 2
                        continue
                i += 1
                continue

            if self._utf8_cont > 0:
                if 0x80 <= b <= 0xBF:
                    self._utf8_cont -= 1
                    i += 1
                    continue
                self._utf8_cont = 0

            if b == 0x1B:  # ESC
                self._wrap_pending = False
                if i + 1 >= n:
                    self._buf = data[i:]
                    break
                nxt = data[i + 1]

                if nxt == 0x5B:  # CSI
                    j = i + 2
                    while j < n and not (0x40 <= data[j] <= 0x7E):
                        j += 1
                    if j >= n:
                        self._buf = data[i:]
                        break
                    final = data[j]
                    params = data[i + 2 : j]
                    try:
                        s = params.decode("ascii", "ignore")
                    except Exception:
                        s = ""

                    if s and s[0] not in "0123456789;":
                        i = j + 1
                        continue

                    parts = s.split(";") if s else []
                    p0 = _parse_int(parts[0] if len(parts) >= 1 else "", 1)
                    p1 = _parse_int(parts[1] if len(parts) >= 2 else "", 1)

                    if final in (ord("H"), ord("f")):
                        self.row = p0
                        self.col = p1
                        _clamp()
                    elif final == ord("A"):
                        self.row = max(1, self.row - p0)
                    elif final == ord("B"):
                        self.row = min(max_row, self.row + p0)
                    elif final == ord("C"):
                        self.col = min(max_col, self.col + p0)
                    elif final == ord("D"):
                        self.col = max(1, self.col - p0)
                    elif final == ord("E"):
                        self.row = min(max_row, self.row + p0)
                        self.col = 1
                    elif final == ord("F"):
                        self.row = max(1, self.row - p0)
                        self.col = 1
                    elif final == ord("G"):
                        self.col = p0
                        _clamp()
                    elif final == ord("d"):
                        self.row = p0
                        _clamp()
                    elif final == ord("r"):
                        # DECSTBM moves the cursor to the home position.
                        self.row = 1
                        self.col = 1
                    elif final == ord("s"):
                        self._saved_row = self.row
                        self._saved_col = self.col
                    elif final == ord("u"):
                        self.row = self._saved_row
                        self.col = self._saved_col
                        _clamp()

                    i = j + 1
                    continue

                # OSC, DCS, PM, APC, SOS (terminated by ST or BEL).
                if nxt == 0x5D or nxt in (0x50, 0x5E, 0x5F, 0x58):
                    self._in_osc = True
                    i += 2
                    continue

                # DECSC / DECRC
                if nxt == 0x37:
                    self._saved_row = self.row
                    self._saved_col = self.col
                    i += 2
                    continue
                if nxt == 0x38:
                    self.row = self._saved_row
                    self.col = self._saved_col
                    _clamp()
                    i += 2
                    continue

                # Other single-escape sequences (ignore).
                i += 2
                continue

            if b == 0x0D:  # CR
                self.col = 1
                self._wrap_pending = False
                i += 1
                continue
            if b in (0x0A, 0x0B, 0x0C):  # LF/VT/FF
                self.row = min(max_row, self.row + 1)
                self._wrap_pending = False
                i += 1
                continue
            if b == 0x08:  # BS
                self.col = max(1, self.col - 1)
                self._wrap_pending = False
                i += 1
                continue
            if b == 0x09:  # TAB
                next_stop = ((self.col - 1) // 8 + 1) * 8 + 1
                self.col = min(max_col, next_stop)
                self._wrap_pending = False
                i += 1
                continue

            if b < 0x20 or b == 0x7F:
                i += 1
                continue

            # Printable characters.
            if self._wrap_pending:
                self.row = min(max_row, self.row + 1)
                self.col = 1
                self._wrap_pending = False

            if b >= 0x80:
                if (b & 0xE0) == 0xC0:
                    self._utf8_cont = 1
                elif (b & 0xF0) == 0xE0:
                    self._utf8_cont = 2
                elif (b & 0xF8) == 0xF0:
                    self._utf8_cont = 3
                else:
                    self._utf8_cont = 0

            if self.col < max_col:
                self.col += 1
            else:
                self.col = max_col
                self._wrap_pending = True

            i += 1


def main():
    if not (sys.stdin.isatty() and sys.stdout.isatty()):
        os.execv(EXEC_TARGET, [EXEC_TARGET] + sys.argv[1:])

    # Start from a clean viewport. Droid's TUI assumes a fresh screen; without this,
    # it can visually mix with prior shell output (especially when scrollback exists).
    try:
        os.write(sys.stdout.fileno(), b"\\x1b[?2026h\\x1b[0m\\x1b[r\\x1b[2J\\x1b[H\\x1b[?2026l")
    except Exception:
        pass

    renderer = StatusRenderer()
    renderer.set_line("\\x1b[48;5;238m\\x1b[38;5;15m Statusline: starting… \\x1b[0m")
    renderer.force_repaint(True)

    physical_rows, physical_cols = _term_size()
    effective_reserved_rows = renderer.desired_reserved_rows(physical_rows, physical_cols, RESERVED_ROWS)
    renderer.set_active_reserved_rows(effective_reserved_rows)

    child_rows = max(4, physical_rows - effective_reserved_rows)
    child_cols = max(10, physical_cols)

    # Reserve the bottom rows up-front, before the child starts writing.
    try:
        seq = f"\\x1b[?2026h\\x1b[?25l\\x1b[1;{child_rows}r\\x1b[1;1H\\x1b[?25h\\x1b[?2026l"
        os.write(sys.stdout.fileno(), seq.encode("utf-8", "ignore"))
    except Exception:
        pass
    renderer.force_repaint(True)
    renderer.render(physical_rows, physical_cols)

    master_fd, slave_fd = pty.openpty()
    _set_winsize(slave_fd, child_rows, child_cols)

    child = subprocess.Popen(
        [EXEC_TARGET] + sys.argv[1:],
        stdin=slave_fd,
        stdout=slave_fd,
        stderr=slave_fd,
        close_fds=True,
        start_new_session=True,
    )
    os.close(slave_fd)

    rewriter = OutputRewriter()
    cursor = CursorTracker()

    monitor = None
    try:
        monitor_env = os.environ.copy()
        try:
            monitor_env["DROID_STATUSLINE_PGID"] = str(os.getpgid(child.pid))
        except Exception:
            monitor_env["DROID_STATUSLINE_PGID"] = str(child.pid)
        monitor = subprocess.Popen(
            ["node", STATUSLINE_MONITOR] + sys.argv[1:],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            close_fds=True,
            bufsize=0,
            env=monitor_env,
        )
    except Exception:
        monitor = None

    monitor_fd = monitor.stdout.fileno() if (monitor and monitor.stdout) else None

    def forward(sig, _frame):
        try:
            os.killpg(child.pid, sig)
        except Exception:
            pass

    for s in (signal.SIGTERM, signal.SIGINT, signal.SIGHUP):
        try:
            signal.signal(s, forward)
        except Exception:
            pass

    stdin_fd = sys.stdin.fileno()
    stdout_fd = sys.stdout.fileno()
    old_tty = termios.tcgetattr(stdin_fd)
    try:
        tty.setraw(stdin_fd)
        # Ensure stdout is blocking (prevents sporadic EAGAIN/BlockingIOError on some terminals).
        try:
            os.set_blocking(stdout_fd, True)
        except Exception:
            pass
        os.set_blocking(stdin_fd, False)
        os.set_blocking(master_fd, False)
        if monitor_fd is not None:
            os.set_blocking(monitor_fd, False)

        monitor_buf = b""
        detect_buf = b""
        cursor_visible = True
        last_physical_rows = 0
        last_physical_cols = 0
        scroll_region_dirty = True

        while True:
            if child.poll() is not None:
                break

            read_fds = [master_fd, stdin_fd]
            if monitor_fd is not None:
                read_fds.append(monitor_fd)

            try:
                rlist, _, _ = select.select(read_fds, [], [], 0.05)
            except InterruptedError:
                rlist = []

            pty_eof = False
            for fd in rlist:
                if fd == stdin_fd:
                    try:
                        data = os.read(stdin_fd, 4096)
                        if data:
                            os.write(master_fd, data)
                    except BlockingIOError:
                        pass
                    except OSError:
                        pass
                elif fd == master_fd:
                    try:
                        data = os.read(master_fd, 65536)
                    except BlockingIOError:
                        data = b""
                    except OSError:
                        data = b""

                    if data:
                        detect_buf = (detect_buf + data)[-96:]
                        if (
                            (b"\\x1b[?1049" in detect_buf)
                            or (b"\\x1b[?1047" in detect_buf)
                            or (b"\\x1b[?47" in detect_buf)
                            or (b"\\x1b[J" in detect_buf)
                            or (b"\\x1b[0J" in detect_buf)
                            or (b"\\x1b[1J" in detect_buf)
                            or (b"\\x1b[2J" in detect_buf)
                        ):
                            renderer.force_repaint(True)
                            scroll_region_dirty = True
                        h = detect_buf.rfind(b"\\x1b[?25h")
                        l = detect_buf.rfind(b"\\x1b[?25l")
                        if h != -1 or l != -1:
                            cursor_visible = h > l
                            renderer.set_cursor_visible(cursor_visible)
                        renderer.note_child_output()
                        data = rewriter.feed(data, child_rows)
                        cursor.feed(data, child_rows, child_cols)
                        try:
                            os.write(stdout_fd, data)
                        except BlockingIOError:
                            # If stdout is non-blocking for some reason, retry briefly.
                            try:
                                time.sleep(0.01)
                                os.write(stdout_fd, data)
                            except Exception:
                                pass
                        except OSError:
                            pass
                    else:
                        pty_eof = True
                elif monitor_fd is not None and fd == monitor_fd:
                    try:
                        chunk = os.read(monitor_fd, 65536)
                    except BlockingIOError:
                        chunk = b""
                    except OSError:
                        chunk = b""

                    if chunk:
                        monitor_buf += chunk
                        while True:
                            nl = monitor_buf.find(b"\\n")
                            if nl == -1:
                                break
                            raw = monitor_buf[:nl].rstrip(b"\\r")
                            monitor_buf = monitor_buf[nl + 1 :]
                            if not raw:
                                continue
                            renderer.set_line(raw.decode("utf-8", "replace"))
                    else:
                        monitor_fd = None

            if pty_eof:
                break

            physical_rows, physical_cols = _term_size()
            size_changed = (physical_rows != last_physical_rows) or (physical_cols != last_physical_cols)

            desired = renderer.desired_reserved_rows(physical_rows, physical_cols, RESERVED_ROWS)
            if size_changed or (desired != effective_reserved_rows):
                cr, cc = cursor.position()
                if desired < effective_reserved_rows:
                    renderer.clear_reserved_area(physical_rows, physical_cols, effective_reserved_rows, cr, cc)

                effective_reserved_rows = desired
                renderer.set_active_reserved_rows(effective_reserved_rows)

                child_rows = max(4, physical_rows - effective_reserved_rows)
                child_cols = max(10, physical_cols)
                _set_winsize(master_fd, child_rows, child_cols)
                try:
                    os.killpg(child.pid, signal.SIGWINCH)
                except Exception:
                    pass

                scroll_region_dirty = True
                renderer.force_repaint(True)
                last_physical_rows = physical_rows
                last_physical_cols = physical_cols

            cr, cc = cursor.position()
            if cr < 1:
                cr = 1
            if cc < 1:
                cc = 1
            if cr > child_rows:
                cr = child_rows
            if cc > child_cols:
                cc = child_cols

            if scroll_region_dirty:
                # Keep the reserved rows out of the terminal scroll region (esp. after resize).
                try:
                    seq = f"\\x1b[?2026h\\x1b[?25l\\x1b[1;{child_rows}r\\x1b[{cr};{cc}H"
                    seq += "\\x1b[?25h" if cursor_visible else "\\x1b[?25l"
                    seq += "\\x1b[?2026l"
                    os.write(stdout_fd, seq.encode("utf-8", "ignore"))
                except Exception:
                    pass
                scroll_region_dirty = False

            renderer.render(physical_rows, physical_cols, cr, cc)

    finally:
        try:
            termios.tcsetattr(stdin_fd, termios.TCSADRAIN, old_tty)
        except Exception:
            pass
        try:
            renderer.clear()
        except Exception:
            pass
        try:
            # Restore terminal scroll region and attributes.
            os.write(stdout_fd, b"\\x1b[r\\x1b[0m\\x1b[?25h")
        except Exception:
            pass
        try:
            os.close(master_fd)
        except Exception:
            pass
        if monitor is not None:
            try:
                monitor.terminate()
            except Exception:
                pass

    sys.exit(child.returncode or 0)


if __name__ == "__main__":
    main()
`;
}

export async function createStatuslineFiles(
  outputDir: string,
  execTargetPath: string,
  aliasName: string,
): Promise<{ wrapperScript: string; monitorScript: string }> {
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const monitorScriptPath = join(outputDir, `${aliasName}-statusline.js`);
  const wrapperScriptPath = join(outputDir, aliasName);

  await writeFile(monitorScriptPath, generateStatuslineMonitorScript());
  await chmod(monitorScriptPath, 0o755);

  await writeFile(
    wrapperScriptPath,
    generateStatuslineWrapperScript(execTargetPath, monitorScriptPath),
  );
  await chmod(wrapperScriptPath, 0o755);

  return { wrapperScript: wrapperScriptPath, monitorScript: monitorScriptPath };
}
