/**
 * WebSearch Patch Generator
 *
 * Two modes:
 * - --websearch: External providers (Smithery, Google PSE, Serper, Brave, SearXNG, DuckDuckGo)
 * - --websearch-proxy: Native provider via proxy plugin (reads ~/.factory/settings.json)
 */

import type { Patch } from "./patcher.ts";
import { writeFile, chmod, mkdir } from "node:fs/promises";
import { join } from "node:path";
import { existsSync } from "node:fs";
import {
  generateSearchProxyServerCode,
  generateExternalSearchProxyServer,
} from "./websearch-external.ts";
import { generateNativeSearchProxyServer } from "./websearch-native.ts";

// Re-export for backward compatibility
export {
  generateSearchProxyServerCode,
  generateExternalSearchProxyServer,
} from "./websearch-external.ts";
export { generateNativeSearchProxyServer } from "./websearch-native.ts";

/**
 * Generate wrapper script for standalone proxy mode
 */
function generateWrapperScript(droidPath: string, proxyScriptPath: string): string {
  return `#!/bin/bash
# Droid with WebSearch Proxy
# Auto-generated by droid-patch --websearch

PROXY_SCRIPT="${proxyScriptPath}"
DROID_BIN="${droidPath}"
PORT_FILE="/tmp/droid-search-proxy-$$.port"

start_proxy() {
  SEARCH_PROXY_PORT_FILE="$PORT_FILE" node "$PROXY_SCRIPT" &
  PROXY_PID=$!
  for i in {1..20}; do
    if [ -f "$PORT_FILE" ]; then
      PORT=$(cat "$PORT_FILE")
      if curl -s "http://127.0.0.1:$PORT/health" > /dev/null 2>&1; then
        echo "[websearch] Proxy started on port $PORT"
        return 0
      fi
    fi
    sleep 0.2
  done
  echo "[websearch] Failed to start proxy"
  kill $PROXY_PID 2>/dev/null
  return 1
}

cleanup() {
  [ -n "$PROXY_PID" ] && kill $PROXY_PID 2>/dev/null
  [ -f "$PORT_FILE" ] && rm -f "$PORT_FILE"
}
trap cleanup EXIT

if ! start_proxy; then exit 1; fi

export FACTORY_API_BASE_URL_OVERRIDE="http://127.0.0.1:$PORT"
exec "$DROID_BIN" "$@"
`;
}

/**
 * Generate WebSearch Patch (legacy binary patch approach)
 */
export function generateWebSearchPatch(): Patch | null {
  const originalUrl = "https://api.factory.ai";
  const localUrl = "http://127.0.0.1:23119";

  if (localUrl.length > originalUrl.length) {
    console.error(`[websearch] Local URL too long: ${localUrl.length} > ${originalUrl.length}`);
    return null;
  }

  const paddedUrl = localUrl.padEnd(originalUrl.length, " ");
  return {
    name: "webSearch",
    description: `Replace API URL with local proxy (${localUrl})`,
    pattern: Buffer.from(originalUrl),
    replacement: Buffer.from(paddedUrl),
  };
}

/**
 * Create WebSearch proxy files (legacy)
 */
export async function createWebSearchProxyFiles(
  outputDir: string,
  droidPath: string,
  aliasName: string,
): Promise<{ proxyScript: string; wrapperScript: string }> {
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const proxyScriptPath = join(outputDir, `${aliasName}-search-proxy.js`);
  const wrapperScriptPath = join(outputDir, `${aliasName}-with-search`);

  await writeFile(proxyScriptPath, generateSearchProxyServerCode());
  console.log(`[*] Created search proxy: ${proxyScriptPath}`);

  await writeFile(wrapperScriptPath, generateWrapperScript(droidPath, proxyScriptPath));
  await chmod(wrapperScriptPath, 0o755);
  console.log(`[*] Created wrapper script: ${wrapperScriptPath}`);

  return { proxyScript: proxyScriptPath, wrapperScript: wrapperScriptPath };
}

/**
 * Get proxy server code (for export)
 */
export function getSearchProxyCode(): string {
  return generateSearchProxyServerCode();
}

/**
 * Generate unified wrapper script
 */
function generateUnifiedWrapper(
  droidPath: string,
  proxyScriptPath: string,
  standalone: boolean = false,
): string {
  const standaloneEnv = standalone ? "STANDALONE_MODE=1 " : "";
  return `#!/bin/bash
# Droid with WebSearch
# Auto-generated by droid-patch --websearch

PROXY_SCRIPT="${proxyScriptPath}"
DROID_BIN="${droidPath}"
PROXY_PID=""
PORT_FILE="/tmp/droid-websearch-$$.port"
STANDALONE="${standalone ? "1" : "0"}"

should_passthrough() {
  for arg in "$@"; do
    if [ "$arg" = "--" ]; then break; fi
    case "$arg" in --help|-h|--version|-V) return 0 ;; esac
  done
  local end_opts=0
  for arg in "$@"; do
    if [ "$arg" = "--" ]; then end_opts=1; continue; fi
    if [ "$end_opts" -eq 0 ] && [[ "$arg" == -* ]]; then continue; fi
    case "$arg" in help|version|completion|completions|exec) return 0 ;; esac
    break
  done
  return 1
}

if should_passthrough "$@"; then exec "$DROID_BIN" "$@"; fi

cleanup() {
  if [ -n "$PROXY_PID" ] && kill -0 "$PROXY_PID" 2>/dev/null; then
    [ -n "$DROID_SEARCH_DEBUG" ] && echo "[websearch] Stopping proxy (PID: $PROXY_PID)" >&2
    kill "$PROXY_PID" 2>/dev/null
    wait "$PROXY_PID" 2>/dev/null
  fi
  rm -f "$PORT_FILE"
}
trap cleanup EXIT INT TERM

[ -n "$DROID_SEARCH_DEBUG" ] && echo "[websearch] Starting proxy..." >&2
[ "$STANDALONE" = "1" ] && [ -n "$DROID_SEARCH_DEBUG" ] && echo "[websearch] Standalone mode enabled" >&2

if [ -n "$DROID_SEARCH_DEBUG" ]; then
  ${standaloneEnv}SEARCH_PROXY_PORT=0 SEARCH_PROXY_PORT_FILE="$PORT_FILE" node "$PROXY_SCRIPT" 2>&1 &
else
  ${standaloneEnv}SEARCH_PROXY_PORT=0 SEARCH_PROXY_PORT_FILE="$PORT_FILE" node "$PROXY_SCRIPT" >/dev/null 2>&1 &
fi
PROXY_PID=$!

for i in {1..50}; do
  if ! kill -0 "$PROXY_PID" 2>/dev/null; then
    [ -n "$DROID_SEARCH_DEBUG" ] && echo "[websearch] Proxy process died" >&2
    break
  fi
  if [ -f "$PORT_FILE" ]; then
    ACTUAL_PORT=$(cat "$PORT_FILE" 2>/dev/null)
    if [ -n "$ACTUAL_PORT" ] && curl -s "http://127.0.0.1:$ACTUAL_PORT/health" > /dev/null 2>&1; then
      [ -n "$DROID_SEARCH_DEBUG" ] && echo "[websearch] Proxy ready on port $ACTUAL_PORT (PID: $PROXY_PID)" >&2
      break
    fi
  fi
  sleep 0.1
done

if [ ! -f "$PORT_FILE" ] || [ -z "$(cat "$PORT_FILE" 2>/dev/null)" ]; then
  echo "[websearch] Failed to start proxy, running without websearch" >&2
  cleanup
  exec "$DROID_BIN" "$@"
fi

ACTUAL_PORT=$(cat "$PORT_FILE")
rm -f "$PORT_FILE"

export FACTORY_API_BASE_URL_OVERRIDE="http://127.0.0.1:$ACTUAL_PORT"
"$DROID_BIN" "$@"
DROID_EXIT_CODE=$?
exit $DROID_EXIT_CODE
`;
}

/**
 * Create unified WebSearch files
 *
 * @param outputDir - Directory to write files to
 * @param droidPath - Path to droid binary
 * @param aliasName - Alias name for the wrapper
 * @param apiBase - Custom API base URL for proxy to forward requests to
 * @param standalone - Standalone mode: mock non-LLM Factory APIs
 * @param useNativeProvider - Use native provider websearch (--websearch-proxy mode)
 */
export async function createWebSearchUnifiedFiles(
  outputDir: string,
  droidPath: string,
  aliasName: string,
  apiBase?: string,
  standalone: boolean = false,
  useNativeProvider: boolean = false,
): Promise<{ wrapperScript: string; preloadScript: string }> {
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const proxyScriptPath = join(outputDir, `${aliasName}-proxy.js`);
  const wrapperScriptPath = join(outputDir, aliasName);

  const factoryApiUrl = apiBase || "https://api.factory.ai";
  const proxyCode = useNativeProvider
    ? generateNativeSearchProxyServer(factoryApiUrl)
    : generateExternalSearchProxyServer(factoryApiUrl);

  await writeFile(proxyScriptPath, proxyCode);
  console.log(`[*] Created proxy script: ${proxyScriptPath}`);
  console.log(
    `[*] Mode: ${useNativeProvider ? "native provider (requires proxy plugin)" : "external providers"}`,
  );

  await writeFile(
    wrapperScriptPath,
    generateUnifiedWrapper(droidPath, proxyScriptPath, standalone),
  );
  await chmod(wrapperScriptPath, 0o755);
  console.log(`[*] Created wrapper: ${wrapperScriptPath}`);

  if (standalone) {
    console.log(`[*] Standalone mode enabled`);
  }

  return {
    wrapperScript: wrapperScriptPath,
    preloadScript: proxyScriptPath,
  };
}

// === Legacy Preload Mode (kept for compatibility) ===

function generatePreloadScript(): string {
  return `// Droid WebSearch Preload Script
const http = require('http');
const https = require('https');
const { execSync } = require('child_process');

const PORT = process.env.DROID_SEARCH_PORT || 23119;
const FACTORY_API = 'https://api.factory.ai';

async function searchGooglePSE(query, num) {
  const apiKey = process.env.GOOGLE_PSE_API_KEY;
  const cx = process.env.GOOGLE_PSE_CX;
  if (!apiKey || !cx) return null;
  try {
    const url = \`https://www.googleapis.com/customsearch/v1?key=\${apiKey}&cx=\${cx}&q=\${encodeURIComponent(query)}&num=\${Math.min(num, 10)}\`;
    const res = await fetch(url);
    const data = await res.json();
    if (data.error) return null;
    return (data.items || []).map(item => ({ title: item.title, url: item.link, content: item.snippet || '' }));
  } catch { return null; }
}

function searchDuckDuckGo(query, num) {
  try {
    const url = \`https://api.duckduckgo.com/?q=\${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1\`;
    const output = execSync(\`curl -s "\${url}"\`, { encoding: 'utf8', timeout: 10000 });
    const data = JSON.parse(output);
    const results = [];
    if (data.AbstractText && data.AbstractURL) {
      results.push({ title: data.Heading || query, url: data.AbstractURL, content: data.AbstractText });
    }
    for (const t of (data.RelatedTopics || [])) {
      if (results.length >= num) break;
      if (t.Text && t.FirstURL) results.push({ title: t.Text.split(' - ')[0], url: t.FirstURL, content: t.Text });
      if (t.Topics) {
        for (const sub of t.Topics) {
          if (results.length >= num) break;
          if (sub.Text && sub.FirstURL) results.push({ title: sub.Text.split(' - ')[0], url: sub.FirstURL, content: sub.Text });
        }
      }
    }
    return results;
  } catch { return []; }
}

async function search(query, num) {
  const googleResults = await searchGooglePSE(query, num);
  if (googleResults?.length > 0) return googleResults;
  return searchDuckDuckGo(query, num);
}

function isPortInUse(port) {
  try { execSync(\`curl -s http://127.0.0.1:\${port}/health\`, { timeout: 1000 }); return true; } catch { return false; }
}

if (!isPortInUse(PORT)) {
  const server = http.createServer(async (req, res) => {
    const url = new URL(req.url, \`http://\${req.headers.host}\`);
    if (url.pathname === '/health') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'ok' }));
      return;
    }
    if (url.pathname === '/api/tools/exa/search' && req.method === 'POST') {
      let body = '';
      req.on('data', c => body += c);
      req.on('end', async () => {
        try {
          const { query, numResults } = JSON.parse(body);
          const results = await search(query, numResults || 10);
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ results }));
        } catch (e) {
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: String(e), results: [] }));
        }
      });
      return;
    }
    const proxyUrl = new URL(FACTORY_API + url.pathname + url.search);
    const proxyReq = https.request(proxyUrl, { method: req.method, headers: { ...req.headers, host: proxyUrl.host } }, proxyRes => {
      res.writeHead(proxyRes.statusCode, proxyRes.headers);
      proxyRes.pipe(res);
    });
    proxyReq.on('error', () => { res.writeHead(502); res.end(); });
    if (req.method !== 'GET' && req.method !== 'HEAD') req.pipe(proxyReq);
    else proxyReq.end();
  });
  server.listen(PORT, '127.0.0.1');
}
`;
}

function generateBunfigToml(preloadScriptPath: string): string {
  return `preload = ["${preloadScriptPath}"]`;
}

function generatePreloadWrapperScript(droidPath: string, bunfigDir: string): string {
  return `#!/bin/bash
cd "${bunfigDir}"
exec "${droidPath}" --cwd "$(pwd)" "$@"
`;
}

export async function createWebSearchPreloadFiles(
  droidDir: string,
  droidPath: string,
  aliasName: string,
): Promise<{ preloadScript: string; bunfigPath: string; wrapperScript: string }> {
  if (!existsSync(droidDir)) {
    await mkdir(droidDir, { recursive: true });
  }

  const preloadScriptPath = join(droidDir, `${aliasName}-search-preload.js`);
  const bunfigPath = join(droidDir, "bunfig.toml");
  const wrapperScriptPath = join(droidDir, aliasName);

  await writeFile(preloadScriptPath, generatePreloadScript());
  await writeFile(bunfigPath, generateBunfigToml(preloadScriptPath));
  await writeFile(wrapperScriptPath, generatePreloadWrapperScript(droidPath, droidDir));
  await chmod(wrapperScriptPath, 0o755);

  console.log(`[*] Created preload: ${preloadScriptPath}`);
  console.log(`[*] Created bunfig: ${bunfigPath}`);
  console.log(`[*] Created wrapper: ${wrapperScriptPath}`);

  return { preloadScript: preloadScriptPath, bunfigPath, wrapperScript: wrapperScriptPath };
}

export function getPreloadScriptCode(): string {
  return generatePreloadScript();
}
