import type { Patch } from "./patcher.ts";
import { writeFile, chmod, mkdir } from "node:fs/promises";
import { join } from "node:path";
import { existsSync } from "node:fs";

/**
 * WebSearch Patch Generator
 *
 * Since injecting code directly into binary is complex (requires exact byte length matching),
 * we use a more practical approach:
 *
 * 1. --websearch option will:
 *    a) Generate a standalone search proxy server script
 *    b) Modify droid's API URL to point to local proxy (using --api-base)
 *    c) Create a wrapper script to start both proxy and droid
 *
 * Environment variables:
 * - GOOGLE_PSE_API_KEY: Google Programmable Search Engine API Key
 * - GOOGLE_PSE_CX: Google Custom Search Engine ID
 * - If not set, will fallback to DuckDuckGo
 */

/**
 * Generate search proxy server code
 */
function generateSearchProxyServerCode(): string {
  return `#!/usr/bin/env node
/**
 * Droid WebSearch Proxy Server
 * Auto-generated by droid-patch --websearch
 * 
 * Supports:
 * - Google PSE (requires GOOGLE_PSE_API_KEY and GOOGLE_PSE_CX)
 * - DuckDuckGo (free fallback)
 */

const http = require('http');
const https = require('https');

const FACTORY_API = 'https://api.factory.ai';

// Auto-find available port
function findAvailablePort(startPort = 23119) {
  return new Promise((resolve, reject) => {
    const net = require('net');
    const server = net.createServer();
    
    server.listen(startPort, '127.0.0.1', () => {
      const port = server.address().port;
      server.close(() => resolve(port));
    });
    
    server.on('error', (err) => {
      if (err.code === 'EADDRINUSE') {
        // Port is in use, try next one
        resolve(findAvailablePort(startPort + 1));
      } else {
        reject(err);
      }
    });
  });
}

let PORT = process.env.SEARCH_PROXY_PORT || 23119;

// === Search Implementation ===

async function searchGooglePSE(query, numResults, apiKey, cx) {
  // Use curl command
  const { execSync } = require('child_process');
  
  const url = 'https://www.googleapis.com/customsearch/v1?key=' + apiKey + '&cx=' + cx + '&q=' + encodeURIComponent(query) + '&num=' + Math.min(numResults, 10);
  const curlCmd = \`curl -s "\${url}"\`;
  
  try {
    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);
    
    return (data.items || []).map(item => ({
      title: item.title,
      url: item.link,
      snippet: item.snippet,
      publishedDate: null,
      author: null,
      score: null
    }));
  } catch (e) {
    throw new Error('Google PSE error: ' + e.message);
  }
}

async function searchDuckDuckGo(query, numResults) {
  // Use curl command, because Node.js fetch may have issues in some environments
  const { execSync } = require('child_process');

  // Method 1: Try using DuckDuckGo HTML lite version (via curl)
  try {
    const curlCmd = \`curl -s -X POST "https://lite.duckduckgo.com/lite/" -H "Content-Type: application/x-www-form-urlencoded" -H "User-Agent: Mozilla/5.0" -d "q=\${encodeURIComponent(query)}"\`;
    const html = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });

    if (html && html.length > 1000) {
      const results = parseDDGLiteHTML(html, numResults);
      if (results.length > 0) {
        console.error('[search] DDG lite returned ' + results.length + ' results');
        return results;
      }
    }
  } catch (e) {
    console.error('[search] DDG lite (curl) failed:', e.message);
  }

  // Method 2: Fallback to Instant Answer API (via curl)
  try {
    const apiUrl = 'https://api.duckduckgo.com/?q=' + encodeURIComponent(query) + '&format=json&no_html=1&skip_disambig=1';
    const curlCmd = \`curl -s "\${apiUrl}" -H "User-Agent: Mozilla/5.0"\`;
    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);
    
    const results = [];

    if (data.Abstract && data.AbstractURL) {
      results.push({
        title: data.Heading || query,
        url: data.AbstractURL,
        snippet: data.Abstract,
        publishedDate: null,
        author: null,
        score: null
      });
    }

    for (const topic of (data.RelatedTopics || [])) {
      if (results.length >= numResults) break;
      if (topic.Text && topic.FirstURL) {
        results.push({
          title: topic.Text.substring(0, 100),
          url: topic.FirstURL,
          snippet: topic.Text,
          publishedDate: null,
          author: null,
          score: null
        });
      }
      if (topic.Topics) {
        for (const st of topic.Topics) {
          if (results.length >= numResults) break;
          if (st.Text && st.FirstURL) {
            results.push({
              title: st.Text.substring(0, 100),
              url: st.FirstURL,
              snippet: st.Text,
              publishedDate: null,
              author: null,
              score: null
            });
          }
        }
      }
    }

    if (results.length > 0) {
      console.error('[search] DDG API returned ' + results.length + ' results');
      return results;
    }
  } catch (e) {
    console.error('[search] DDG API (curl) failed:', e.message);
  }

  return [];
}

// Parse DuckDuckGo Lite HTML
function parseDDGLiteHTML(html, maxResults) {
  const results = [];

  // Match result links - DuckDuckGo Lite format
  // <a rel="nofollow" href="URL">TITLE</a>
  const linkRegex = /<a[^>]+rel="nofollow"[^>]+href="([^"]+)"[^>]*>([^<]+)<\\/a>/gi;
  const snippetRegex = /<td[^>]*class="result-snippet"[^>]*>([^<]*)<\\/td>/gi;

  const links = [];
  let match;

  // Extract all links
  while ((match = linkRegex.exec(html)) !== null && links.length < maxResults) {
    let url = match[1];
    // Skip DuckDuckGo internal links
    if (url.includes('duckduckgo.com') && !url.includes('uddg=')) continue;
    // Decode redirect URL
    if (url.includes('uddg=')) {
      const uddgMatch = url.match(/uddg=([^&]+)/);
      if (uddgMatch) url = decodeURIComponent(uddgMatch[1]);
    }
    links.push({
      url: url,
      title: decodeHTMLEntities(match[2].trim())
    });
  }

  // Extract snippets
  const snippets = [];
  while ((match = snippetRegex.exec(html)) !== null && snippets.length < maxResults) {
    snippets.push(decodeHTMLEntities(match[1].trim()));
  }

  // Combine results
  for (let i = 0; i < links.length && results.length < maxResults; i++) {
    results.push({
      title: links[i].title,
      url: links[i].url,
      snippet: snippets[i] || '',
      publishedDate: null,
      author: null,
      score: null
    });
  }
  
  return results;
}

function decodeHTMLEntities(str) {
  return str
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ');
}

async function search(query, numResults = 10) {
  const googleApiKey = process.env.GOOGLE_PSE_API_KEY;
  const googleCx = process.env.GOOGLE_PSE_CX;

  // Try Google PSE first
  if (googleApiKey && googleCx) {
    try {
      console.error('[search] Trying Google PSE...');
      const results = await searchGooglePSE(query, numResults, googleApiKey, googleCx);
      if (results.length > 0) {
        console.error('[search] Google PSE returned ' + results.length + ' results');
        return { results, source: 'google-pse' };
      }
    } catch (e) {
      console.error('[search] Google PSE failed:', e.message);
    }
  }

  // Fallback to DuckDuckGo
  try {
    console.error('[search] Using DuckDuckGo...');
    const results = await searchDuckDuckGo(query, numResults);
    console.error('[search] DuckDuckGo returned ' + results.length + ' results');
    return { results, source: 'duckduckgo' };
  } catch (e) {
    console.error('[search] DuckDuckGo failed:', e.message);
  }

  return { results: [], source: 'none' };
}

// === HTTP Server ===

const server = http.createServer(async (req, res) => {
  const url = new URL(req.url, 'http://' + req.headers.host);

  // Health check
  if (url.pathname === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ 
      status: 'ok',
      google: !!(process.env.GOOGLE_PSE_API_KEY && process.env.GOOGLE_PSE_CX),
      duckduckgo: true
    }));
    return;
  }

  // Search endpoint
  if (url.pathname === '/api/tools/exa/search' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const { query, numResults } = JSON.parse(body);
        console.error('[search] Query: "' + query + '"');
        
        const { results, source } = await search(query, numResults || 10);
        console.error('[search] ' + results.length + ' results from ' + source);
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ results }));
      } catch (e) {
        console.error('[search] Error:', e);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: String(e), results: [] }));
      }
    });
    return;
  }

  // Proxy other requests to Factory API
  console.error('[proxy] ' + req.method + ' ' + url.pathname);
  
  const proxyUrl = new URL(FACTORY_API + url.pathname + url.search);
  
  const proxyReq = https.request(proxyUrl, {
    method: req.method,
    headers: { ...req.headers, host: proxyUrl.host }
  }, proxyRes => {
    res.writeHead(proxyRes.statusCode, proxyRes.headers);
    proxyRes.pipe(res);
  });

  proxyReq.on('error', e => {
    console.error('[proxy] Error:', e.message);
    res.writeHead(502, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Proxy failed' }));
  });

  if (req.method !== 'GET' && req.method !== 'HEAD') {
    req.pipe(proxyReq);
  } else {
    proxyReq.end();
  }
});

// Start server (async, auto-find available port)
(async () => {
  const fs = require('fs');
  const path = require('path');

  // If port not specified, auto-find available port
  if (!process.env.SEARCH_PROXY_PORT) {
    PORT = await findAvailablePort(23119);
  }

  server.listen(PORT, '127.0.0.1', () => {
    const hasGoogle = process.env.GOOGLE_PSE_API_KEY && process.env.GOOGLE_PSE_CX;

    // Write port number to temp file for wrapper script to read
    const portFile = process.env.SEARCH_PROXY_PORT_FILE || path.join(require('os').tmpdir(), 'droid-search-proxy-' + process.pid + '.port');
    fs.writeFileSync(portFile, PORT.toString());

    // Output port number to stdout (for parent process to capture)
    console.log('PORT=' + PORT);
    
    console.error('');
    console.error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.error('â•‘         Droid WebSearch Proxy                                 â•‘');
    console.error('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.error('â•‘  ðŸ” Google PSE: ' + (hasGoogle ? 'Configured âœ“' : 'Not set (set GOOGLE_PSE_API_KEY & CX)').padEnd(45) + 'â•‘');
    console.error('â•‘  ðŸ¦† DuckDuckGo: Always available                              â•‘');
    console.error('â•‘  ðŸš€ Server: http://127.0.0.1:' + PORT + '                            â•‘'.slice(0, 65) + 'â•‘');
    console.error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.error('');
  });
})();

// Handle graceful shutdown
process.on('SIGTERM', () => server.close());
process.on('SIGINT', () => server.close());
`;
}

/**
 * Generate wrapper script, auto-start proxy and droid
 */
function generateWrapperScript(droidPath: string, proxyScriptPath: string): string {
  return `#!/bin/bash
# Droid with WebSearch Proxy
# Auto-generated by droid-patch --websearch

PROXY_SCRIPT="${proxyScriptPath}"
DROID_BIN="${droidPath}"
PORT_FILE="/tmp/droid-search-proxy-$$.port"

# Start proxy and get dynamic port
start_proxy() {
  # Start proxy, capture output to get port
  SEARCH_PROXY_PORT_FILE="$PORT_FILE" node "$PROXY_SCRIPT" &
  PROXY_PID=$!

  # Wait for proxy to start and get port
  for i in {1..20}; do
    if [ -f "$PORT_FILE" ]; then
      PORT=$(cat "$PORT_FILE")
      if curl -s "http://127.0.0.1:$PORT/health" > /dev/null 2>&1; then
        echo "[websearch] Proxy started on port $PORT"
        return 0
      fi
    fi
    sleep 0.2
  done

  echo "[websearch] Failed to start proxy"
  kill $PROXY_PID 2>/dev/null
  return 1
}

# Cleanup function
cleanup() {
  [ -n "$PROXY_PID" ] && kill $PROXY_PID 2>/dev/null
  [ -f "$PORT_FILE" ] && rm -f "$PORT_FILE"
}
trap cleanup EXIT

# Start proxy
if ! start_proxy; then
  exit 1
fi

# Run droid
export FACTORY_API_BASE_URL_OVERRIDE="http://127.0.0.1:$PORT"
exec "$DROID_BIN" "$@"
`;
}

/**
 * Generate WebSearch Patch
 *
 * Since injecting code directly into binary is complex, we use the following strategy:
 * 1. Create proxy server script
 * 2. Modify API URL to point to local
 * 3. Return a combined patch
 */
export function generateWebSearchPatch(): Patch | null {
  // Return a URL replacement patch
  // Use local proxy port 23119 (idle port)
  const originalUrl = "https://api.factory.ai";
  const localUrl = "http://127.0.0.1:23119";

  // Need to pad to same length
  if (localUrl.length > originalUrl.length) {
    console.error(`[websearch] Local URL too long: ${localUrl.length} > ${originalUrl.length}`);
    return null;
  }

  const paddedUrl = localUrl.padEnd(originalUrl.length, " ");

  return {
    name: "webSearch",
    description: `Replace API URL with local proxy (${localUrl})`,
    pattern: Buffer.from(originalUrl),
    replacement: Buffer.from(paddedUrl),
  };
}

/**
 * Create WebSearch proxy files
 */
export async function createWebSearchProxyFiles(
  outputDir: string,
  droidPath: string,
  aliasName: string,
): Promise<{ proxyScript: string; wrapperScript: string }> {
  // Ensure directory exists
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const proxyScriptPath = join(outputDir, `${aliasName}-search-proxy.js`);
  const wrapperScriptPath = join(outputDir, `${aliasName}-with-search`);

  // Write proxy server script
  await writeFile(proxyScriptPath, generateSearchProxyServerCode());
  console.log(`[*] Created search proxy: ${proxyScriptPath}`);

  // Write wrapper script
  await writeFile(wrapperScriptPath, generateWrapperScript(droidPath, proxyScriptPath));
  await chmod(wrapperScriptPath, 0o755);
  console.log(`[*] Created wrapper script: ${wrapperScriptPath}`);

  return {
    proxyScript: proxyScriptPath,
    wrapperScript: wrapperScriptPath,
  };
}

/**
 * Get proxy server code (for export)
 */
export function getSearchProxyCode(): string {
  return generateSearchProxyServerCode();
}

/**
 * Generate Bun preload script
 * This script executes before droid main program, starts search proxy
 */
function generatePreloadScript(): string {
  return `// Droid WebSearch Preload Script
// Auto-generated by droid-patch --websearch-preload
// Start search proxy before droid main program

const http = require('http');
const https = require('https');
const { execSync } = require('child_process');

const PORT = process.env.DROID_SEARCH_PORT || 23119;
const FACTORY_API = 'https://api.factory.ai';

// Google PSE search
async function searchGooglePSE(query, num) {
  const apiKey = process.env.GOOGLE_PSE_API_KEY;
  const cx = process.env.GOOGLE_PSE_CX;
  if (!apiKey || !cx) return null;
  
  try {
    const url = \`https://www.googleapis.com/customsearch/v1?key=\${apiKey}&cx=\${cx}&q=\${encodeURIComponent(query)}&num=\${Math.min(num, 10)}\`;
    const res = await fetch(url);
    const data = await res.json();
    if (data.error) return null;
    return (data.items || []).map(item => ({
      title: item.title,
      url: item.link,
      content: item.snippet || ''
    }));
  } catch (e) {
    return null;
  }
}

// DuckDuckGo search (use curl for reliability)
function searchDuckDuckGo(query, num) {
  try {
    const url = \`https://api.duckduckgo.com/?q=\${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1\`;
    const output = execSync(\`curl -s "\${url}"\`, { encoding: 'utf8', timeout: 10000 });
    const data = JSON.parse(output);
    const results = [];

    if (data.AbstractText && data.AbstractURL) {
      results.push({ title: data.Heading || query, url: data.AbstractURL, content: data.AbstractText });
    }

    for (const t of (data.RelatedTopics || [])) {
      if (results.length >= num) break;
      if (t.Text && t.FirstURL) {
        results.push({ title: t.Text.split(' - ')[0], url: t.FirstURL, content: t.Text });
      }
      // Handle subcategories
      if (t.Topics) {
        for (const sub of t.Topics) {
          if (results.length >= num) break;
          if (sub.Text && sub.FirstURL) {
            results.push({ title: sub.Text.split(' - ')[0], url: sub.FirstURL, content: sub.Text });
          }
        }
      }
    }
    return results;
  } catch (e) {
    return [];
  }
}

// Search function
async function search(query, num) {
  // Try Google PSE first
  const googleResults = await searchGooglePSE(query, num);
  if (googleResults && googleResults.length > 0) {
    console.error('[preload-search] Using Google PSE');
    return googleResults;
  }

  // Fallback to DuckDuckGo
  console.error('[preload-search] Using DuckDuckGo');
  return searchDuckDuckGo(query, num);
}

// Check if port is already in use
function isPortInUse(port) {
  try {
    execSync(\`curl -s http://127.0.0.1:\${port}/health\`, { timeout: 1000 });
    return true;
  } catch {
    return false;
  }
}

// Skip if proxy already running
if (isPortInUse(PORT)) {
  console.error(\`[preload] Search proxy already running on port \${PORT}\`);
} else {
  // Start proxy server
  const server = http.createServer(async (req, res) => {
    const url = new URL(req.url, \`http://\${req.headers.host}\`);

    // Health check
    if (url.pathname === '/health') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'ok' }));
      return;
    }

    // Search endpoint
    if (url.pathname === '/api/tools/exa/search' && req.method === 'POST') {
      let body = '';
      req.on('data', c => body += c);
      req.on('end', async () => {
        try {
          const { query, numResults } = JSON.parse(body);
          console.error(\`[preload-search] Query: "\${query}"\`);
          const results = await search(query, numResults || 10);
          console.error(\`[preload-search] Found \${results.length} results\`);
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ results }));
        } catch (e) {
          console.error('[preload-search] Error:', e.message);
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: String(e), results: [] }));
        }
      });
      return;
    }

    // Proxy other requests to Factory API
    const proxyUrl = new URL(FACTORY_API + url.pathname + url.search);
    const proxyReq = https.request(proxyUrl, {
      method: req.method,
      headers: { ...req.headers, host: proxyUrl.host }
    }, proxyRes => {
      res.writeHead(proxyRes.statusCode, proxyRes.headers);
      proxyRes.pipe(res);
    });
    proxyReq.on('error', (e) => {
      console.error('[preload-proxy] Error:', e.message);
      res.writeHead(502, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Proxy failed' }));
    });
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      req.pipe(proxyReq);
    } else {
      proxyReq.end();
    }
  });

  server.listen(PORT, '127.0.0.1', () => {
    console.error(\`[preload] Search proxy started on http://127.0.0.1:\${PORT}\`);
  });
}
`;
}

/**
 * Generate bunfig.toml content
 */
function generateBunfigToml(preloadScriptPath: string): string {
  return `# Droid WebSearch Configuration
# Auto-generated by droid-patch --websearch-preload

preload = ["${preloadScriptPath}"]
`;
}

/**
 * Generate preload wrapper script
 * This script cd's to the bunfig.toml directory, then executes droid
 */
function generatePreloadWrapperScript(droidPath: string, bunfigDir: string): string {
  return `#!/bin/bash
# Droid with WebSearch (Preload)
# Auto-generated by droid-patch --preload

BUNFIG_DIR="${bunfigDir}"
DROID_BIN="${droidPath}"
ORIGINAL_DIR="$(pwd)"

# cd to bunfig.toml directory (Bun reads bunfig.toml from cwd)
cd "$BUNFIG_DIR"

# Execute droid, pass all arguments, set working directory to original
exec "$DROID_BIN" --cwd "$ORIGINAL_DIR" "$@"
`;
}

/**
 * Create WebSearch files using Preload method
 *
 * Advantages:
 * - No need to modify binary
 * - Uses Bun's native preload mechanism
 *
 * Files created:
 * - preload script (search proxy)
 * - bunfig.toml (Bun configuration)
 * - wrapper script (directly executable command)
 */
export async function createWebSearchPreloadFiles(
  droidDir: string,
  droidPath: string,
  aliasName: string,
): Promise<{
  preloadScript: string;
  bunfigPath: string;
  wrapperScript: string;
}> {
  // Ensure directory exists
  if (!existsSync(droidDir)) {
    await mkdir(droidDir, { recursive: true });
  }

  const preloadScriptPath = join(droidDir, `${aliasName}-search-preload.js`);
  const bunfigPath = join(droidDir, "bunfig.toml");
  const wrapperScriptPath = join(droidDir, aliasName);

  // Write preload script
  await writeFile(preloadScriptPath, generatePreloadScript());
  console.log(`[*] Created preload script: ${preloadScriptPath}`);

  // Write bunfig.toml
  await writeFile(bunfigPath, generateBunfigToml(preloadScriptPath));
  console.log(`[*] Created bunfig.toml: ${bunfigPath}`);

  // Write wrapper script
  await writeFile(wrapperScriptPath, generatePreloadWrapperScript(droidPath, droidDir));
  await chmod(wrapperScriptPath, 0o755);
  console.log(`[*] Created wrapper: ${wrapperScriptPath}`);

  return {
    preloadScript: preloadScriptPath,
    bunfigPath: bunfigPath,
    wrapperScript: wrapperScriptPath,
  };
}

/**
 * Get preload script code (for export)
 */
export function getPreloadScriptCode(): string {
  return generatePreloadScript();
}

/**
 * Generate unified Fetch Hook Preload script
 * Directly hooks globalThis.fetch, no proxy server needed
 * @internal Reserved for future use - alternative to proxy server approach
 */
function _generateFetchHookPreload(): string {
  return `// Droid WebSearch Fetch Hook
// Auto-generated by droid-patch --websearch
// Hook globalThis.fetch to intercept search requests

const DEBUG = process.env.DROID_SEARCH_DEBUG === '1';

function log(...args) {
  if (DEBUG) console.error('[websearch]', ...args);
}

// === Search Implementation ===

async function searchGooglePSE(query, numResults) {
  const apiKey = process.env.GOOGLE_PSE_API_KEY;
  const cx = process.env.GOOGLE_PSE_CX;
  if (!apiKey || !cx) return null;

  try {
    const url = \`https://www.googleapis.com/customsearch/v1?key=\${apiKey}&cx=\${cx}&q=\${encodeURIComponent(query)}&num=\${Math.min(numResults, 10)}\`;
    const res = await fetch(url);
    const data = await res.json();
    if (data.error) {
      log('Google PSE error:', data.error.message);
      return null;
    }
    return (data.items || []).map(item => ({
      title: item.title,
      url: item.link,
      content: item.snippet || '',
      publishedDate: null,
      author: null,
      score: null
    }));
  } catch (e) {
    log('Google PSE failed:', e.message);
    return null;
  }
}

async function searchDuckDuckGo(query, numResults) {
  const { execSync } = require('child_process');

  // Method 1: Try DuckDuckGo HTML lite
  try {
    const curlCmd = \`curl -s -X POST "https://lite.duckduckgo.com/lite/" -H "Content-Type: application/x-www-form-urlencoded" -H "User-Agent: Mozilla/5.0" -d "q=\${encodeURIComponent(query)}"\`;
    const html = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });

    if (html && html.length > 1000) {
      const results = parseDDGLiteHTML(html, numResults);
      if (results.length > 0) {
        log('DDG lite:', results.length, 'results');
        return results;
      }
    }
  } catch (e) {
    log('DDG lite failed:', e.message);
  }

  // Method 2: Fallback to Instant Answer API
  try {
    const apiUrl = \`https://api.duckduckgo.com/?q=\${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1\`;
    const curlCmd = \`curl -s "\${apiUrl}" -H "User-Agent: Mozilla/5.0"\`;
    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);

    const results = [];

    if (data.Abstract && data.AbstractURL) {
      results.push({
        title: data.Heading || query,
        url: data.AbstractURL,
        content: data.Abstract,
        publishedDate: null,
        author: null,
        score: null
      });
    }

    for (const topic of (data.RelatedTopics || [])) {
      if (results.length >= numResults) break;
      if (topic.Text && topic.FirstURL) {
        results.push({
          title: topic.Text.substring(0, 100),
          url: topic.FirstURL,
          content: topic.Text,
          publishedDate: null,
          author: null,
          score: null
        });
      }
      if (topic.Topics) {
        for (const st of topic.Topics) {
          if (results.length >= numResults) break;
          if (st.Text && st.FirstURL) {
            results.push({
              title: st.Text.substring(0, 100),
              url: st.FirstURL,
              content: st.Text,
              publishedDate: null,
              author: null,
              score: null
            });
          }
        }
      }
    }

    if (results.length > 0) {
      log('DDG API:', results.length, 'results');
      return results;
    }
  } catch (e) {
    log('DDG API failed:', e.message);
  }

  return [];
}

function parseDDGLiteHTML(html, maxResults) {
  const results = [];
  const linkRegex = /<a[^>]+rel="nofollow"[^>]+href="([^"]+)"[^>]*>([^<]+)<\\/a>/gi;
  const snippetRegex = /<td[^>]*class="result-snippet"[^>]*>([^<]*)<\\/td>/gi;

  const links = [];
  let match;

  while ((match = linkRegex.exec(html)) !== null && links.length < maxResults) {
    let url = match[1];
    if (url.includes('duckduckgo.com') && !url.includes('uddg=')) continue;
    if (url.includes('uddg=')) {
      const uddgMatch = url.match(/uddg=([^&]+)/);
      if (uddgMatch) url = decodeURIComponent(uddgMatch[1]);
    }
    links.push({
      url: url,
      title: decodeHTMLEntities(match[2].trim())
    });
  }

  const snippets = [];
  while ((match = snippetRegex.exec(html)) !== null && snippets.length < maxResults) {
    snippets.push(decodeHTMLEntities(match[1].trim()));
  }

  for (let i = 0; i < links.length && results.length < maxResults; i++) {
    results.push({
      title: links[i].title,
      url: links[i].url,
      content: snippets[i] || '',
      publishedDate: null,
      author: null,
      score: null
    });
  }

  return results;
}

function decodeHTMLEntities(str) {
  return str
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ');
}

async function search(query, numResults = 10) {
  // Try Google PSE first
  const googleResults = await searchGooglePSE(query, numResults);
  if (googleResults && googleResults.length > 0) {
    log('Using Google PSE');
    return { results: googleResults, source: 'google-pse' };
  }

  // Fallback to DuckDuckGo
  log('Using DuckDuckGo');
  const ddgResults = await searchDuckDuckGo(query, numResults);
  return { results: ddgResults, source: 'duckduckgo' };
}

// === Fetch Hook ===

const originalFetch = globalThis.fetch;

globalThis.fetch = async function(input, init) {
  const url = typeof input === 'string' ? input : (input instanceof URL ? input.href : input.url);

  // Intercept search requests
  if (url && url.includes('/api/tools/exa/search')) {
    log('Intercepted search request');

    try {
      let body = init?.body;
      if (body && typeof body !== 'string') {
        body = await new Response(body).text();
      }

      const { query, numResults } = JSON.parse(body || '{}');
      log('Query:', query);

      const { results, source } = await search(query, numResults || 10);
      log('Results:', results.length, 'from', source);

      return new Response(JSON.stringify({ results }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      });
    } catch (e) {
      log('Search error:', e.message);
      return new Response(JSON.stringify({ error: String(e), results: [] }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }

  // Pass through all other requests
  return originalFetch.apply(this, arguments);
};

// Also hook Bun.fetch if available
if (typeof Bun !== 'undefined' && Bun.fetch) {
  const originalBunFetch = Bun.fetch;
  Bun.fetch = globalThis.fetch;
}

log('Fetch hook installed');
`;
}

/**
 * Generate search proxy server code (runs in background)
 * Since BUN_CONFIG_PRELOAD doesn't work with compiled binaries,
 * use a local proxy server to intercept search requests instead
 *
 * Each droid instance runs its own proxy server.
 * The proxy is killed automatically when droid exits.
 * @param factoryApiUrl - Custom Factory API URL (default: https://api.factory.ai)
 */
function generateSearchProxyServer(factoryApiUrl: string = "https://api.factory.ai"): string {
  return `#!/usr/bin/env node
// Droid WebSearch Proxy Server
// Auto-generated by droid-patch --websearch
// This proxy runs as a child process of droid and is killed when droid exits

const http = require('http');
const https = require('https');
const { execSync } = require('child_process');
const fs = require('fs');

const DEBUG = process.env.DROID_SEARCH_DEBUG === '1';
const PORT = parseInt(process.env.SEARCH_PROXY_PORT || '0'); // 0 = auto-assign
const FACTORY_API = '${factoryApiUrl}';

function log(...args) {
  if (DEBUG) console.error('[websearch]', ...args);
}

// === Search Implementation ===

// Smithery Exa MCP - highest priority, requires SMITHERY_API_KEY and SMITHERY_PROFILE
async function searchSmitheryExa(query, numResults) {
  const apiKey = process.env.SMITHERY_API_KEY;
  const profile = process.env.SMITHERY_PROFILE;
  if (!apiKey || !profile) return null;

  try {
    // Construct URL with authentication
    const serverUrl = \`https://server.smithery.ai/exa/mcp?api_key=\${encodeURIComponent(apiKey)}&profile=\${encodeURIComponent(profile)}\`;
    log('Smithery Exa request');

    // Use MCP protocol to call the search tool via HTTP POST
    const requestBody = JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'tools/call',
      params: {
        name: 'web_search_exa',
        arguments: {
          query: query,
          numResults: numResults
        }
      }
    });

    const curlCmd = \`curl -s -X POST "\${serverUrl}" -H "Content-Type: application/json" -d '\${requestBody.replace(/'/g, "'\\\\\\\\''")}'\`;
    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 30000 });
    const response = JSON.parse(jsonStr);

    // Parse MCP response
    if (response.result && response.result.content) {
      // MCP returns content as array of text blocks
      const textContent = response.result.content.find(c => c.type === 'text');
      if (textContent && textContent.text) {
        try {
          const searchResults = JSON.parse(textContent.text);
          if (Array.isArray(searchResults) && searchResults.length > 0) {
            return searchResults.slice(0, numResults).map(item => ({
              title: item.title || '',
              url: item.url || '',
              content: item.text || item.snippet || item.highlights?.join(' ') || '',
              publishedDate: item.publishedDate || null,
              author: item.author || null,
              score: item.score || null
            }));
          }
        } catch (parseErr) {
          log('Smithery response parsing failed');
        }
      }
    }

    if (response.error) {
      log('Smithery Exa error:', response.error.message || response.error);
      return null;
    }
  } catch (e) {
    log('Smithery Exa failed:', e.message);
    return null;
  }
  return null;
}

async function searchGooglePSE(query, numResults) {
  const apiKey = process.env.GOOGLE_PSE_API_KEY;
  const cx = process.env.GOOGLE_PSE_CX;
  if (!apiKey || !cx) return null;

  try {
    const url = \`https://www.googleapis.com/customsearch/v1?key=\${apiKey}&cx=\${cx}&q=\${encodeURIComponent(query)}&num=\${Math.min(numResults, 10)}\`;
    log('Google PSE request:', url.replace(apiKey, '***'));

    const curlCmd = \`curl -s "\${url}"\`;
    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);

    if (data.error) {
      log('Google PSE error:', data.error.message);
      return null;
    }
    return (data.items || []).map(item => ({
      title: item.title,
      url: item.link,
      content: item.snippet || '',
      publishedDate: null,
      author: null,
      score: null
    }));
  } catch (e) {
    log('Google PSE failed:', e.message);
    return null;
  }
}

// SearXNG - self-hosted meta search engine
async function searchSearXNG(query, numResults) {
  const searxngUrl = process.env.SEARXNG_URL;
  if (!searxngUrl) return null;

  try {
    const url = \`\${searxngUrl}/search?q=\${encodeURIComponent(query)}&format=json&engines=google,bing,duckduckgo\`;
    log('SearXNG request:', url);

    const curlCmd = \`curl -s "\${url}" -H "Accept: application/json"\`;
    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);

    if (data.results && data.results.length > 0) {
      return data.results.slice(0, numResults).map(item => ({
        title: item.title,
        url: item.url,
        content: item.content || '',
        publishedDate: null,
        author: null,
        score: null
      }));
    }
  } catch (e) {
    log('SearXNG failed:', e.message);
  }
  return null;
}

// Serper API - free tier available (2500 queries/month)
async function searchSerper(query, numResults) {
  const apiKey = process.env.SERPER_API_KEY;
  if (!apiKey) return null;

  try {
    const curlCmd = \`curl -s "https://google.serper.dev/search" -H "X-API-KEY: \${apiKey}" -H "Content-Type: application/json" -d '{"q":"\${query.replace(/"/g, '\\\\"')}","num":\${numResults}}'\`;
    log('Serper request');

    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);

    if (data.organic && data.organic.length > 0) {
      return data.organic.slice(0, numResults).map(item => ({
        title: item.title,
        url: item.link,
        content: item.snippet || '',
        publishedDate: null,
        author: null,
        score: null
      }));
    }
  } catch (e) {
    log('Serper failed:', e.message);
  }
  return null;
}

// Brave Search API - free tier available
async function searchBrave(query, numResults) {
  const apiKey = process.env.BRAVE_API_KEY;
  if (!apiKey) return null;

  try {
    const url = \`https://api.search.brave.com/res/v1/web/search?q=\${encodeURIComponent(query)}&count=\${numResults}\`;
    const curlCmd = \`curl -s "\${url}" -H "Accept: application/json" -H "X-Subscription-Token: \${apiKey}"\`;
    log('Brave request');

    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);

    if (data.web && data.web.results && data.web.results.length > 0) {
      return data.web.results.slice(0, numResults).map(item => ({
        title: item.title,
        url: item.url,
        content: item.description || '',
        publishedDate: null,
        author: null,
        score: null
      }));
    }
  } catch (e) {
    log('Brave failed:', e.message);
  }
  return null;
}

// DuckDuckGo - limited reliability due to bot detection
async function searchDuckDuckGo(query, numResults) {
  // DuckDuckGo Instant Answer API (limited results but more reliable)
  try {
    const apiUrl = \`https://api.duckduckgo.com/?q=\${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1\`;
    const curlCmd = \`curl -s "\${apiUrl}" -H "User-Agent: Mozilla/5.0"\`;
    const jsonStr = execSync(curlCmd, { encoding: 'utf-8', timeout: 15000 });
    const data = JSON.parse(jsonStr);

    const results = [];

    if (data.Abstract && data.AbstractURL) {
      results.push({
        title: data.Heading || query,
        url: data.AbstractURL,
        content: data.Abstract,
        publishedDate: null,
        author: null,
        score: null
      });
    }

    for (const topic of (data.RelatedTopics || [])) {
      if (results.length >= numResults) break;
      if (topic.Text && topic.FirstURL) {
        results.push({
          title: topic.Text.substring(0, 100),
          url: topic.FirstURL,
          content: topic.Text,
          publishedDate: null,
          author: null,
          score: null
        });
      }
      if (topic.Topics) {
        for (const st of topic.Topics) {
          if (results.length >= numResults) break;
          if (st.Text && st.FirstURL) {
            results.push({
              title: st.Text.substring(0, 100),
              url: st.FirstURL,
              content: st.Text,
              publishedDate: null,
              author: null,
              score: null
            });
          }
        }
      }
    }

    if (results.length > 0) {
      log('DDG API:', results.length, 'results');
      return results;
    }
  } catch (e) {
    log('DDG API failed:', e.message);
  }

  return [];
}

function parseDDGLiteHTML(html, maxResults) {
  const results = [];
  const linkRegex = /<a[^>]+rel="nofollow"[^>]+href="([^"]+)"[^>]*>([^<]+)<\\/a>/gi;
  const snippetRegex = /<td[^>]*class="result-snippet"[^>]*>([^<]*)<\\/td>/gi;

  const links = [];
  let match;

  while ((match = linkRegex.exec(html)) !== null && links.length < maxResults) {
    let url = match[1];
    if (url.includes('duckduckgo.com') && !url.includes('uddg=')) continue;
    if (url.includes('uddg=')) {
      const uddgMatch = url.match(/uddg=([^&]+)/);
      if (uddgMatch) url = decodeURIComponent(uddgMatch[1]);
    }
    links.push({
      url: url,
      title: decodeHTMLEntities(match[2].trim())
    });
  }

  const snippets = [];
  while ((match = snippetRegex.exec(html)) !== null && snippets.length < maxResults) {
    snippets.push(decodeHTMLEntities(match[1].trim()));
  }

  for (let i = 0; i < links.length && results.length < maxResults; i++) {
    results.push({
      title: links[i].title,
      url: links[i].url,
      content: snippets[i] || '',
      publishedDate: null,
      author: null,
      score: null
    });
  }

  return results;
}

function decodeHTMLEntities(str) {
  return str
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ');
}

async function search(query, numResults = 10) {
  // Priority order:
  // 1. Smithery Exa MCP (best quality if configured)
  // 2. Google PSE (most reliable if configured)
  // 3. Serper (free tier: 2500/month)
  // 4. Brave Search (free tier available)
  // 5. SearXNG (self-hosted)
  // 6. DuckDuckGo (limited due to bot detection)

  // 1. Smithery Exa MCP (highest priority)
  const smitheryResults = await searchSmitheryExa(query, numResults);
  if (smitheryResults && smitheryResults.length > 0) {
    log('Using Smithery Exa');
    return { results: smitheryResults, source: 'smithery-exa' };
  }

  // 2. Google PSE
  const googleResults = await searchGooglePSE(query, numResults);
  if (googleResults && googleResults.length > 0) {
    log('Using Google PSE');
    return { results: googleResults, source: 'google-pse' };
  }

  // 3. Serper
  const serperResults = await searchSerper(query, numResults);
  if (serperResults && serperResults.length > 0) {
    log('Using Serper');
    return { results: serperResults, source: 'serper' };
  }

  // 4. Brave Search
  const braveResults = await searchBrave(query, numResults);
  if (braveResults && braveResults.length > 0) {
    log('Using Brave Search');
    return { results: braveResults, source: 'brave' };
  }

  // 5. SearXNG
  const searxngResults = await searchSearXNG(query, numResults);
  if (searxngResults && searxngResults.length > 0) {
    log('Using SearXNG');
    return { results: searxngResults, source: 'searxng' };
  }

  // 6. DuckDuckGo (last resort, limited results)
  log('Using DuckDuckGo (fallback)');
  const ddgResults = await searchDuckDuckGo(query, numResults);
  return { results: ddgResults, source: 'duckduckgo' };
}

// === HTTP Proxy Server ===

const server = http.createServer(async (req, res) => {
  const url = new URL(req.url, \`http://\${req.headers.host}\`);

  // Health check
  if (url.pathname === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', port: server.address()?.port || PORT }));
    return;
  }

  // Search endpoint - intercept
  if (url.pathname === '/api/tools/exa/search' && req.method === 'POST') {
    let body = '';
    req.on('data', c => body += c);
    req.on('end', async () => {
      try {
        const { query, numResults } = JSON.parse(body);
        log('Search query:', query);
        const { results, source } = await search(query, numResults || 10);
        log('Results:', results.length, 'from', source);
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ results }));
      } catch (e) {
        log('Search error:', e.message);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: String(e), results: [] }));
      }
    });
    return;
  }

  // === Standalone mode (controlled by STANDALONE_MODE env) ===
  // Whitelist approach: only allow core LLM APIs, mock everything else
  if (process.env.STANDALONE_MODE === '1') {
    const pathname = url.pathname;

    // Whitelist: Core APIs that should be forwarded to upstream
    const isCoreLLMApi = pathname.startsWith('/api/llm/a/') || pathname.startsWith('/api/llm/o/');
    // /api/tools/exa/search is already handled above

    if (!isCoreLLMApi) {
      // Special handling for specific routes
      if (pathname === '/api/sessions/create') {
        log('Mock (dynamic):', pathname);
        const sessionId = \`local-\${Date.now()}-\${Math.random().toString(36).slice(2, 10)}\`;
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ id: sessionId }));
        return;
      }

      if (pathname === '/api/cli/whoami') {
        log('Mock (401):', pathname);
        res.writeHead(401, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Unauthorized', message: 'Local mode - use token fallback' }));
        return;
      }

      if (pathname === '/api/tools/get-url-contents') {
        log('Mock (404):', pathname);
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Not available', message: 'Use local URL fetch fallback' }));
        return;
      }

      // All other non-core APIs: return empty success
      log('Mock (default):', pathname);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({}));
      return;
    }
  }

  // Proxy core LLM requests to upstream API
  log('Proxy:', req.method, url.pathname);

  const proxyUrl = new URL(FACTORY_API + url.pathname + url.search);
  // Choose http or https based on target protocol
  const proxyModule = proxyUrl.protocol === 'https:' ? https : http;
  const proxyReq = proxyModule.request(proxyUrl, {
    method: req.method,
    headers: { ...req.headers, host: proxyUrl.host }
  }, proxyRes => {
    res.writeHead(proxyRes.statusCode, proxyRes.headers);
    proxyRes.pipe(res);
  });

  proxyReq.on('error', e => {
    log('Proxy error:', e.message);
    res.writeHead(502, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Proxy failed: ' + e.message }));
  });

  if (req.method !== 'GET' && req.method !== 'HEAD') {
    req.pipe(proxyReq);
  } else {
    proxyReq.end();
  }
});

// If port is 0, system will automatically assign an available port
server.listen(PORT, '127.0.0.1', () => {
  const actualPort = server.address().port;
  const hasGoogle = process.env.GOOGLE_PSE_API_KEY && process.env.GOOGLE_PSE_CX;

  // Write port file for parent process to read
  const portFile = process.env.SEARCH_PROXY_PORT_FILE;
  if (portFile) {
    fs.writeFileSync(portFile, String(actualPort));
  }

  // Output PORT= line for wrapper script to parse
  console.log('PORT=' + actualPort);

  const hasSmithery = process.env.SMITHERY_API_KEY && process.env.SMITHERY_PROFILE;
  log('Search proxy started on http://127.0.0.1:' + actualPort);
  log('Smithery Exa:', hasSmithery ? 'configured (priority 1)' : 'not set');
  log('Google PSE:', hasGoogle ? 'configured' : 'not set');
  log('Serper:', process.env.SERPER_API_KEY ? 'configured' : 'not set');
  log('Brave:', process.env.BRAVE_API_KEY ? 'configured' : 'not set');
  log('SearXNG:', process.env.SEARXNG_URL || 'not set');
});

process.on('SIGTERM', () => { server.close(); process.exit(0); });
process.on('SIGINT', () => { server.close(); process.exit(0); });
`;
}

/**
 * Generate unified Wrapper script
 * Each droid instance runs its own proxy:
 * - Uses port 0 to let system auto-assign available port
 * - Proxy runs as child process
 * - Proxy is killed when droid exits
 * - Supports multiple droid instances running simultaneously
 */
/* eslint-disable no-useless-escape */
function generateUnifiedWrapper(
  droidPath: string,
  proxyScriptPath: string,
  standalone: boolean = false,
): string {
  const standaloneEnv = standalone ? "STANDALONE_MODE=1 " : "";
  return `#!/bin/bash
# Droid with WebSearch
# Auto-generated by droid-patch --websearch
# Each instance runs its own proxy on a system-assigned port

PROXY_SCRIPT="${proxyScriptPath}"
DROID_BIN="${droidPath}"
PROXY_PID=""
PORT_FILE="/tmp/droid-websearch-\$\$.port"
STANDALONE="${standalone ? "1" : "0"}"

# Passthrough for non-interactive/meta commands (avoid starting a proxy for help/version/etc)
should_passthrough() {
  # Any help/version flags before "--"
  for arg in "\$@"; do
    if [ "\$arg" = "--" ]; then
      break
    fi
    case "\$arg" in
      --help|-h|--version|-V)
        return 0
        ;;
    esac
  done

  # Top-level command token
  local end_opts=0
  for arg in "\$@"; do
    if [ "\$arg" = "--" ]; then
      end_opts=1
      continue
    fi
    if [ "\$end_opts" -eq 0 ] && [[ "\$arg" == -* ]]; then
      continue
    fi
    case "\$arg" in
      help|version|completion|completions|exec)
        return 0
        ;;
    esac
    break
  done

  return 1
}

if should_passthrough "\$@"; then
  exec "\$DROID_BIN" "\$@"
fi

# Cleanup function - kill proxy when droid exits
cleanup() {
  if [ -n "\$PROXY_PID" ] && kill -0 "\$PROXY_PID" 2>/dev/null; then
    [ -n "\$DROID_SEARCH_DEBUG" ] && echo "[websearch] Stopping proxy (PID: \$PROXY_PID)" >&2
    kill "\$PROXY_PID" 2>/dev/null
    wait "\$PROXY_PID" 2>/dev/null
  fi
  rm -f "\$PORT_FILE"
}

# Set up trap to cleanup on exit
trap cleanup EXIT INT TERM

[ -n "\$DROID_SEARCH_DEBUG" ] && echo "[websearch] Starting proxy..." >&2
[ "\$STANDALONE" = "1" ] && [ -n "\$DROID_SEARCH_DEBUG" ] && echo "[websearch] Standalone mode enabled" >&2

# Start proxy with port 0 (system will assign available port)
# Proxy writes actual port to PORT_FILE
if [ -n "\$DROID_SEARCH_DEBUG" ]; then
  ${standaloneEnv}SEARCH_PROXY_PORT=0 SEARCH_PROXY_PORT_FILE="\$PORT_FILE" node "\$PROXY_SCRIPT" 2>&1 &
else
  ${standaloneEnv}SEARCH_PROXY_PORT=0 SEARCH_PROXY_PORT_FILE="\$PORT_FILE" node "\$PROXY_SCRIPT" >/dev/null 2>&1 &
fi
PROXY_PID=\$!

# Wait for proxy to start and get actual port (max 5 seconds)
for i in {1..50}; do
  # Check if proxy process is still running
  if ! kill -0 "\$PROXY_PID" 2>/dev/null; then
    [ -n "\$DROID_SEARCH_DEBUG" ] && echo "[websearch] Proxy process died" >&2
    break
  fi
  if [ -f "\$PORT_FILE" ]; then
    ACTUAL_PORT=\$(cat "\$PORT_FILE" 2>/dev/null)
    if [ -n "\$ACTUAL_PORT" ] && curl -s "http://127.0.0.1:\$ACTUAL_PORT/health" > /dev/null 2>&1; then
      [ -n "\$DROID_SEARCH_DEBUG" ] && echo "[websearch] Proxy ready on port \$ACTUAL_PORT (PID: \$PROXY_PID)" >&2
      break
    fi
  fi
  sleep 0.1
done

# Check if proxy started successfully
if [ ! -f "\$PORT_FILE" ] || [ -z "\$(cat "\$PORT_FILE" 2>/dev/null)" ]; then
  echo "[websearch] Failed to start proxy, running without websearch" >&2
  cleanup
  exec "\$DROID_BIN" "\$@"
fi

ACTUAL_PORT=\$(cat "\$PORT_FILE")
rm -f "\$PORT_FILE"

# Run droid with proxy
export FACTORY_API_BASE_URL_OVERRIDE="http://127.0.0.1:\$ACTUAL_PORT"
"\$DROID_BIN" "\$@"
DROID_EXIT_CODE=\$?

# Cleanup will be called by trap
exit \$DROID_EXIT_CODE
`;
}
/* eslint-enable no-useless-escape */

/**
 * Create unified WebSearch files
 *
 * Approach: Proxy server mode
 * - wrapper script starts local proxy server
 * - proxy server intercepts search requests, passes through other requests
 * - uses FACTORY_API_BASE_URL_OVERRIDE env var to point to proxy
 * - alias works directly, no extra steps needed
 *
 * @param outputDir - Directory to write files to
 * @param droidPath - Path to droid binary
 * @param aliasName - Alias name for the wrapper
 * @param apiBase - Custom API base URL for proxy to forward requests to
 * @param standalone - Standalone mode: mock non-LLM Factory APIs
 */
export async function createWebSearchUnifiedFiles(
  outputDir: string,
  droidPath: string,
  aliasName: string,
  apiBase?: string,
  standalone: boolean = false,
): Promise<{ wrapperScript: string; preloadScript: string }> {
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const proxyScriptPath = join(outputDir, `${aliasName}-proxy.js`);
  const wrapperScriptPath = join(outputDir, aliasName);

  // Write proxy server script with custom API base if provided
  const factoryApiUrl = apiBase || "https://api.factory.ai";
  await writeFile(proxyScriptPath, generateSearchProxyServer(factoryApiUrl));
  console.log(`[*] Created proxy script: ${proxyScriptPath}`);

  // Write unified wrapper
  await writeFile(
    wrapperScriptPath,
    generateUnifiedWrapper(droidPath, proxyScriptPath, standalone),
  );
  await chmod(wrapperScriptPath, 0o755);
  console.log(`[*] Created wrapper: ${wrapperScriptPath}`);

  if (standalone) {
    console.log(`[*] Standalone mode enabled`);
  }

  return {
    wrapperScript: wrapperScriptPath,
    preloadScript: proxyScriptPath, // Keep interface compatible
  };
}
